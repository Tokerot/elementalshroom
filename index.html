<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental Shrooms - Pack Opener</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 30%, #334155 70%, #475569 100%);
            background-attachment: fixed;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Glassmorphism effect for main panels */
        .glass-panel {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* Enhanced stat cards */
        .stat-card {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .card {
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #4a5568, #2d3748);
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden; /* Keep effects contained */
            width: 200px; /* Fixed width for consistency */
            height: 280px; /* Fixed height for consistency */
            flex-shrink: 0; /* Prevent shrinking in flex containers */
        }
        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
        }
        .common-border { border-color: #9ca3af; }
        .uncommon-border { border-color: #22c55e; }
        .rare-border { border-color: #3b82f6; }
        .ultra_rare-border { border-color: #a855f7; }
        .secret_rare-border { border-color: #f59e0b; }
        
        .holo::before, .prismatic::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none;
            z-index: 1;
        }

        .holo::before {
            background: linear-gradient(
                110deg,
                transparent 40%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 60%
            );
            animation: holo-shine 5s infinite linear;
        }
        @keyframes holo-shine {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .prismatic::before {
            background: linear-gradient(
                110deg,
                rgba(255, 0, 0, 0.3) 10%,
                rgba(255, 165, 0, 0.3) 20%,
                rgba(255, 255, 0, 0.3) 30%,
                rgba(0, 255, 0, 0.3) 40%,
                rgba(0, 0, 255, 0.3) 50%,
                rgba(75, 0, 130, 0.3) 60%,
                rgba(238, 130, 238, 0.3) 70%,
                rgba(255, 0, 0, 0.3) 80%
            );
            background-size: 200% 200%;
            animation: prismatic-sweep 6s infinite linear;
        }

        @keyframes prismatic-sweep {
            0% { transform: translateX(-50%) translateY(-25%) rotate(25deg); }
            100% { transform: translateX(25%) translateY(50%) rotate(25deg); }
        }

        .full-art {
            background-size: cover;
            background-position: center;
            border-width: 6px;
        }
        .full-art .card-content {
            background-color: rgba(0,0,0,0.7);
            border-radius: 0.25rem;
            padding: 0.25rem;
        }

        /* Text area backgrounds for regular cards (not full art) */
        .card:not(.full-art) .card-name-area {
            background-color: rgba(0,0,0,0.7);
            border-radius: 0.375rem;
            padding: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .card:not(.full-art) .card-effect-content {
            background-color: rgba(0,0,0,0.7);
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
        }

        .card:not(.full-art) .card-value-display {
            background-color: rgba(0,0,0,0.7);
            border-radius: 0.375rem;
            padding: 0.25rem;
            margin: 0.25rem;
        }

        /* Misprint finish effects */
        .misprint {
            position: relative;
            border: 3px solid #ff0000 !important;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

        .misprint::before {
            content: '⚠️ MISPRINT';
            position: absolute;
            top: 2px;
            right: 2px;
            background: linear-gradient(45deg, #ff0000, #ff6600);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: bold;
            z-index: 10;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            animation: misprint-flash 2s infinite;
        }

        @keyframes misprint-flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Misprint error effects */
        .misprint-name-error {
            color: #ff6666 !important;
            text-decoration: line-through;
            position: relative;
        }

        .misprint-name-error::after {
            content: attr(data-corrected);
            position: absolute;
            top: -0.2em;
            left: 0;
            color: #ffffff;
            text-decoration: none;
            font-size: 0.9em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .misprint-text-missing {
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 0, 0.3) 2px,
                rgba(255, 0, 0, 0.3) 4px
            );
        }

        .misprint-image-error {
            filter: hue-rotate(180deg) saturate(1.5);
        }



        .misprint-image-offset {
            transform: translate(10px, -5px);
        }

        .misprint-image-inverted {
            filter: invert(1);
        }
        .card-content-wrapper {
            position: relative;
            z-index: 2; /* Ensure content is above effect layers */
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 0.25rem;
        }
        .card-name-area {
            flex-shrink: 0;
        }
        .card-name {
            text-align: center;
            font-weight: bold;
            line-height: 1.1;
            margin-bottom: 0.25rem;
            word-wrap: break-word;
            hyphens: auto;
        }
        .card-name.long-name {
            font-size: 0.75rem;
        }
        .card-name.very-long-name {
            font-size: 0.625rem;
        }
        .card-type-icons {
            position: absolute;
            top: 3rem; /* Below name area with background box */
            right: 0.25rem;
            display: flex;
            gap: 0.25rem;
            font-size: 1.5rem;
            line-height: 1;
        }
        .card-type-icons.dual-type {
            left: 0.25rem;
            right: 0.25rem;
            justify-content: space-between;
        }
        .card:not(.full-art) .card-type-icon {
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Scaled-up card for detail modal */
        .card-scaled {
            width: 400px !important;
            height: 560px !important;
            transform: none !important;
        }
        .card-scaled .card-type-icon {
            width: 4rem !important;
            height: 4rem !important;
            font-size: 2rem !important;
        }
        .card-scaled .card-type-icons {
            font-size: 2rem !important;
            top: 6rem !important;
        }
        .card-scaled .card-name {
            font-size: 1.5rem !important;
        }
        .card-scaled .card-rarity-info {
            font-size: 1rem !important;
        }
        .card-scaled .card-content {
            font-size: 0.875rem !important; /* Smaller scaled text */
        }
        .card-scaled .card-value-display {
            font-size: 1.25rem !important;
        }
        .card-rarity-info {
            text-align: center;
            font-size: 0.75rem;
            color: #9ca3af;
            line-height: 1;
            height: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .card-rarity-info.long-info {
            font-size: 0.625rem;
        }
        .card-value-display {
            position: absolute;
            bottom: 0.01rem;
            left: 0;
            right: 0;
            text-align: center;
            font-weight: 600;
            color: #10b981;
        }
        .card-effect-content {
            position: absolute;
            bottom: 1.5rem;
            left: 0.125rem;
            right: 0.125rem;
            z-index: 3;
            text-align: center;
        }
        /* Card-button container for opened cards */
        .card-with-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            width: 200px; /* Match card width exactly */
        }
        .card-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
            width: 100%;
        }
        .card .card-content {
            pointer-events: none;
            text-align: center;
            font-size: 0.8rem; /* Smaller than before */
            color: #fbbf24; /* Amber color for effect text */
            font-style: italic;
            line-height: 1.2;
        }
        .modal-backdrop {
            background-color: rgba(0,0,0,0.75);
        }
        .progress-bar-inner {
            transition: width 0.5s ease-in-out;
        }
        .card .grid button {
            pointer-events: auto;
        }
        .card .grid button:hover {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }
        .shop-item {
            transition: all 0.2s ease;
        }
        .shop-item:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }
        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #4a5568;
        }
        .shop-item.disabled:hover {
            transform: none;
            box-shadow: none;
        }
        .playmat-fire {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/fire.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-water {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/water.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-electric {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/electric.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-grass {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/grass.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-psychic {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/psychic.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-neutral {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/metal.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        .playmat-wild {
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('playmats/wild.jpg');
            background-repeat: repeat;
            background-size: 300px 300px;
            background-attachment: fixed;
        }
        
        .collection-book-tab.active {
            border-color: #f59e0b;
            background-color: #ca8a04;
        }
        .tooltip-container {
            position: relative;
            cursor: pointer;
        }
        .tooltip {
            display: none;
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            width: 220px;
            pointer-events: none;
        }
        .tooltip-container:hover .tooltip {
            display: block;
        }
        .tooltip .card:hover {
            transform: none;
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #ca8a04;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .card-indicator {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            z-index: 3;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        .indicator-new { background-color: #f97316; } /* Orange */
        .indicator-upgrade { background-color: #eab308; } /* Yellow */
        .card-condition {
            position: absolute;
            top: 0.25rem;
            left: 0.25rem;
            z-index: 3;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: bold;
            pointer-events: none;
        }
        .gem-mint {
            background: linear-gradient(45deg, #fde047, #f59e0b);
            color: #422006;
            text-shadow: 0 0 5px white;
            animation: gem-shine 2s infinite;
        }
        @keyframes gem-shine {
            0%, 100% { box-shadow: 0 0 5px #fef08a; }
            50% { box-shadow: 0 0 15px #fde047; }
        }
        .card-pull-rate {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 3;
            background-color: rgba(0,0,0,0.8);
            color: #f59e0b; /* Amber */
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.7rem;
            font-weight: bold;
        }
        .highlight {
            box-shadow: 0 0 15px 5px #facc15, 0 4px 15px rgba(0, 0, 0, 0.2) !important; /* gold glow + base shadow */
            transform: translateY(-5px);
        }

        .highlight:hover {
            box-shadow: 0 0 20px 8px #facc15, 0 15px 35px rgba(0, 0, 0, 0.4) !important; /* stronger gold glow + hover shadow */
        }
        .elemental-icon:hover {
            transform: scale(1.2);
        }
        .elemental-icon.active {
            transform: scale(1.2);
            filter: drop-shadow(0 0 5px #fde047);
        }

        /* Deckbox Background Themes */
        .deckbox-cardboard {
            background: linear-gradient(135deg, #d2b48c, #daa520) !important;
            border: 2px solid #8b7355 !important;
        }

        .deckbox-plastic {
            background: linear-gradient(135deg, #4a5568, #2d3748) !important;
            border: 2px solid #718096 !important;
        }

        .deckbox-reinforced {
            background: linear-gradient(135deg, #c0c0c0, #a8a8a8) !important;
            border: 2px solid #696969 !important;
        }

        .deckbox-vault {
            background: linear-gradient(135deg, #ffd700, #ffb347) !important;
            border: 2px solid #daa520 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3) !important;
        }

        /* Sleeves Background Themes (Pack Opening Area) */
        .sleeves-penny {
            background: linear-gradient(135deg, #f5f5dc, #e6e6fa) !important;
            border: 2px solid #d3d3d3 !important;
        }

        .sleeves-protective {
            background: linear-gradient(135deg, #87ceeb, #b0e0e6) !important;
            border: 2px solid #4682b4 !important;
        }

        .sleeves-lucky {
            background: linear-gradient(135deg, #98fb98, #90ee90) !important;
            border: 2px solid #32cd32 !important;
        }

        .sleeves-holo {
            background: linear-gradient(135deg, #ff69b4, #ffc0cb, #da70d6) !important;
            border: 2px solid #ff1493 !important;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.3) !important;
        }

        .sleeves-gilded {
            background: linear-gradient(135deg, #ffd700, #ffef94) !important;
            border: 2px solid #b8860b !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2) !important;
        }

        .sleeves-dragon {
            background: linear-gradient(135deg, #8b0000, #dc143c) !important;
            border: 2px solid #800000 !important;
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.4) !important;
        }

        .sleeves-starlight {
            background: linear-gradient(135deg, #191970, #4169e1, #6495ed) !important;
            border: 2px solid #000080 !important;
            box-shadow: 0 0 25px rgba(65, 105, 225, 0.5) !important;
        }

        /* Binder Background Themes (Sidebar) */
        .binder-folder {
            background: linear-gradient(135deg, #deb887, #f4a460) !important;
            border: 2px solid #cd853f !important;
        }

        .binder-collector {
            background: linear-gradient(135deg, #2f4f4f, #708090) !important;
            border: 2px solid #556b2f !important;
        }

        .binder-trader {
            background: linear-gradient(135deg, #800080, #9370db) !important;
            border: 2px solid #4b0082 !important;
        }

        .binder-pro {
            background: linear-gradient(135deg, #ff4500, #ff6347) !important;
            border: 2px solid #dc143c !important;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.3) !important;
        }

        .binder-master {
            background: linear-gradient(135deg, #9400d3, #8a2be2, #7b68ee) !important;
            border: 2px solid #6a0dad !important;
            box-shadow: 0 0 25px rgba(148, 0, 211, 0.4) !important;
        }

        /* Enhanced buttons */
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            border: 1px solid rgba(107, 114, 128, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            border: 1px solid rgba(16, 185, 129, 0.3);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.2);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.2);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: 1px solid rgba(245, 158, 11, 0.3);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.2);
        }

        /* Animated progress bars */
        .progress-bar-animated {
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #3b82f6);
            background-size: 200% 100%;
            animation: progress-shimmer 2s infinite;
        }

        @keyframes progress-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Enhanced title styling */
        .game-title {
            background: linear-gradient(135deg, #fbbf24, #f59e0b, #d97706);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
            animation: title-glow 3s ease-in-out infinite alternate;
        }

        @keyframes title-glow {
            from { filter: drop-shadow(0 0 5px rgba(251, 191, 36, 0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(251, 191, 36, 0.8)); }
        }

        /* Enhanced section headers */
        .section-header {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border-bottom: 2px solid rgba(59, 130, 246, 0.3);
            position: relative;
        }

        .section-header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }

        .section-header:hover::after {
            width: 100%;
        }

        /* Enhanced card effects */
        .card {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card:hover {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Floating animation for important elements */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        .float-animation {
            animation: float 3s ease-in-out infinite;
        }

        /* Pulse animation for notifications */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.8); }
        }

        .pulse-glow {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        /* Improved modal backdrop */
        .modal-backdrop {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        /* Enhanced shop items */
        .shop-item {
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
        }

        .shop-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Notification styling */
        .notification {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9));
            border: 1px solid rgba(16, 185, 129, 0.3);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.2);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body id="body-background" class="bg-gray-900 text-white p-4 sm:p-8 transition-colors duration-500">

    <div id="game-container" class="max-w-full mx-auto grid grid-cols-1 lg:grid-cols-5 gap-8 px-4">

        <div class="lg:col-span-1 glass-panel p-6 rounded-2xl flex flex-col gap-6 h-fit">
            <h1 class="text-4xl font-bold text-center game-title float-animation">🍄 Elemental Shrooms</h1>
            
            <div class="grid grid-cols-2 gap-4 text-center">
                <div class="stat-card p-4 rounded-xl">
                    <p class="text-sm text-gray-300 font-medium">Money</p>
                    <p id="money-display" class="text-2xl font-bold text-emerald-400 mt-1">$50</p>
                </div>
                <div class="stat-card p-4 rounded-xl">
                    <p class="text-sm text-gray-300 font-medium">Deck Value</p>
                    <p id="deck-value-display" class="text-2xl font-bold text-blue-400 mt-1">$0</p>
                </div>
                <div class="stat-card p-4 rounded-xl">
                    <p class="text-sm text-gray-300 font-medium">Deck Size</p>
                    <p id="deck-count" class="text-2xl font-bold text-blue-400 mt-1">0 / 50</p>
                </div>
                 <div class="stat-card p-4 rounded-xl">
                    <p class="text-sm text-gray-300 font-medium">Sells Left</p>
                    <p id="sell-count" class="text-2xl font-bold text-emerald-400 mt-1">1</p>
                </div>
                 <div class="stat-card p-4 rounded-xl col-span-2">
                    <p class="text-sm text-gray-300 font-medium">Burns Left</p>
                    <p id="burn-count" class="text-2xl font-bold text-red-400 mt-1">1</p>
                </div>
            </div>

            <div class="grid grid-cols-1 gap-3">
                <button id="end-run-btn" class="w-full btn-danger font-bold py-3 px-4 rounded-xl transition-all">End Run</button>
                <button id="collection-book-btn" class="w-full btn-primary font-bold py-3 px-4 rounded-xl transition-all">Collection</button>
                <button id="big-book-btn" class="w-full btn-secondary font-bold py-3 px-4 rounded-xl transition-all">📚 The Big Book</button>
            </div>
            
            <div class="stat-card p-5 rounded-xl">
                <h3 class="text-lg font-semibold text-center mb-3 text-white">Unlock Progress</h3>
                <p class="text-sm text-center text-gray-300 font-medium" id="unlock-label">Gen 2 Unlock</p>
                <div class="bg-gray-900 rounded-full h-3 mt-3 overflow-hidden border border-gray-600">
                    <div id="unlock-progress-bar" class="progress-bar-animated h-3 rounded-full" style="width: 0%;"></div>
                </div>
                <p class="text-sm text-center mt-2 text-gray-300" id="unlock-progress-text">$0 / $2,500</p>
            </div>

            <div>
                <h2 class="section-header text-xl font-semibold mb-3 text-center p-3 rounded-t-xl text-white">Equipped Gear</h2>
                <div id="equipped-gear-list" class="stat-card p-4 rounded-b-xl min-h-[100px] text-sm space-y-2">
                    <p class="text-gray-400">None.</p>
                </div>
            </div>

            <div>
                <h2 class="section-header text-xl font-semibold mb-3 text-center p-3 rounded-t-xl text-white">Active Effects</h2>
                <div id="active-effects-list" class="stat-card p-4 rounded-b-xl min-h-[100px] overflow-y-auto text-sm space-y-2">
                    <p class="text-gray-400">None yet!</p>
                </div>
            </div>


        </div>

        <div class="lg:col-span-4">
            <div id="shop-section" class="glass-panel p-8 rounded-2xl mb-8">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-4xl font-bold text-center flex-grow game-title">🍄 Mushroom Mart</h2>
                    <div class="flex items-center gap-3">
                         <button id="info-btn" class="btn-secondary text-white font-bold py-3 px-5 rounded-xl transition-all">Info</button>
                        <button id="enter-shop-btn" class="btn-warning text-gray-900 font-bold py-3 px-5 rounded-xl transition-all">Full Shop</button>
                    </div>
                </div>
                <div id="shop-grid" class="grid grid-cols-1 md:grid-cols-3 gap-6">
                </div>
            </div>

            <div id="elemental-counts-bar" class="glass-panel p-4 rounded-xl mb-8 flex items-center gap-x-4 gap-y-2 flex-wrap">
                <div id="elemental-counts-icons" class="flex items-center gap-x-4 gap-y-2 flex-wrap">
                </div>
                <div id="run-counters" class="flex items-center gap-x-4 gap-y-2 flex-wrap text-xs text-gray-400 border-l border-gray-600 ml-2 pl-4">
                </div>
                <div class="ml-auto flex items-center gap-2">
                    <button id="autoplay-btn" class="hidden bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded-lg text-xs transition-colors">🤖 Autoplay</button>
                    <button id="sell-all-btn" class="hidden bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-xs transition-colors">Sell All</button>
                    <label for="toggle-condition" class="flex items-center gap-2 cursor-pointer" title="Toggle Condition Indicator">
                        <input type="checkbox" id="toggle-condition" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-600">
                        <span class="card-condition static text-xs">9.5</span>
                    </label>
                    <label for="toggle-new" class="flex items-center gap-2 cursor-pointer" title="Toggle New Card Indicator">
                        <input type="checkbox" id="toggle-new" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-orange-500 focus:ring-orange-600">
                        <span class="card-indicator indicator-new static w-5 h-5 text-xs">!</span>
                    </label>
                    <label for="toggle-upgrade" class="flex items-center gap-2 cursor-pointer" title="Toggle Upgrade Value Indicator">
                        <input type="checkbox" id="toggle-upgrade" class="form-checkbox h-4 w-4 rounded bg-gray-700 border-gray-600 text-yellow-500 focus:ring-yellow-600">
                        <span class="card-indicator indicator-upgrade static w-5 h-5 text-xs">$</span>
                    </label>
                </div>
            </div>

            <div id="pack-opening-section" class="min-h-[50vh] glass-panel p-6 rounded-2xl">
                 <div id="pack-opening-grid" class="flex flex-wrap justify-start gap-4">
                </div>
            </div>

            <!-- New Deck Section -->
            <div id="deck-section" class="glass-panel p-6 rounded-2xl mt-6">
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center gap-4">
                        <h2 class="text-2xl font-bold text-white game-title">🃏 Current Deck</h2>
                        <div class="flex items-center gap-2 text-sm">
                            <span class="bg-blue-500/20 px-3 py-1 rounded-full text-blue-300">
                                <span id="deck-summary-count">0</span> cards
                            </span>
                            <span class="bg-green-500/20 px-3 py-1 rounded-full text-green-300">
                                $<span id="deck-summary-value">0</span>
                            </span>
                        </div>
                    </div>
                    <div class="flex items-center gap-3">
                        <select id="deck-sort" class="bg-gray-700 text-white px-3 py-2 rounded-lg text-sm">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                            <option value="value-high">Highest Value</option>
                            <option value="value-low">Lowest Value</option>
                            <option value="rarity">By Rarity</option>
                            <option value="name">By Name</option>
                        </select>
                        <button id="deck-toggle" class="btn-secondary px-4 py-2 rounded-lg text-sm">
                            <span id="deck-toggle-text">Hide</span> <span id="deck-toggle-icon">▼</span>
                        </button>
                    </div>
                </div>

                <div id="deck-content" class="transition-all duration-300">
                    <div id="deck-grid-new" class="grid grid-cols-6 md:grid-cols-8 lg:grid-cols-10 xl:grid-cols-12 gap-3">
                        <!-- Deck cards will be populated here -->
                    </div>

                    <div id="deck-pagination" class="flex justify-center items-center gap-4 mt-6 hidden">
                        <button id="deck-prev-page" class="btn-secondary px-4 py-2 rounded-lg disabled:opacity-50">
                            ← Previous
                        </button>
                        <span id="deck-page-info" class="text-gray-300">
                            Page 1 of 1
                        </span>
                        <button id="deck-next-page" class="btn-secondary px-4 py-2 rounded-lg disabled:opacity-50">
                            Next →
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="glass-panel rounded-2xl p-8 text-center max-w-lg mx-auto border-2 border-red-500/30">
            <h2 id="modal-title" class="text-4xl font-extrabold mb-4 text-red-400 game-title">Run Over</h2>
            <p id="modal-message" class="text-lg mb-2 text-gray-300">Your deck is full!</p>
            
            <div class="bg-gray-700 rounded-lg p-4 my-4 text-left space-y-2">
                <div><span class="font-semibold text-gray-400">Final Deck Value:</span> <span id="modal-final-value" class="float-right font-bold text-blue-400">$0</span></div>
                <div><span class="font-semibold text-gray-400">New Cards Value:</span> <span id="modal-new-cards-value" class="float-right font-bold text-green-400">+$0</span></div>
                <div><span class="font-semibold text-gray-400">Collection Value:</span> <span id="modal-collection-value" class="float-right font-bold text-purple-400">$0</span></div>
            </div>

            <p class="text-sm text-yellow-300 mb-2" id="modal-progress-update"></p>

            <div class="flex justify-center items-start gap-12 my-4">
                <div class="flex flex-col items-center">
                    <h3 class="text-lg font-bold mb-2">Most Valuable Card</h3>
                    <div id="modal-best-card" class="w-[150px] flex justify-center">
                    </div>
                </div>
                <div id="modal-reward-card-container" class="hidden flex flex-col items-center">
                    <h3 class="text-lg font-bold mb-2">Run Reward</h3>
                    <div id="modal-reward-card" class="w-[150px] flex justify-center">
                    </div>
                </div>
            </div>

            <button id="modal-claim-reward-btn" class="hidden mt-8 btn-primary text-white font-bold py-4 px-8 rounded-xl text-lg transition-all">
                Claim Reward
            </button>

            <button id="modal-new-run-btn" class="mt-8 btn-warning text-gray-900 font-bold py-4 px-8 rounded-xl text-lg transition-all">
                Start New Run
            </button>

            <button id="modal-close-btn" class="hidden mt-8 btn-secondary text-white font-bold py-4 px-8 rounded-xl text-lg transition-all">
                Close
            </button>
        </div>
    </div>

    <div id="full-shop-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="glass-panel rounded-2xl p-6 text-center max-w-7xl w-full mx-auto h-[90vh] flex flex-col border border-white/20">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-4xl font-extrabold text-yellow-400">The Bazaar</h2>
                <button id="close-shop-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="flex-grow grid grid-cols-4 gap-6 overflow-hidden">
                <div class="col-span-3 flex flex-col gap-6">
                    <div class="flex-shrink-0">
                        <h3 class="text-2xl font-bold border-b-2 border-yellow-500 pb-2 mb-4 text-left">Pack Licensing</h3>
                        <div id="pack-licensing-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
                    </div>
                    <div class="flex-grow flex flex-col overflow-hidden">
                        <div class="flex justify-between items-center mb-4 flex-shrink-0">
                            <h3 class="text-2xl font-bold border-b-2 border-yellow-500 pb-2 text-left">Merchandise</h3>
                            <button id="restock-merch-btn" class="bg-green-600 hover:bg-green-700 font-bold py-2 px-4 rounded-lg">Restock ($5)</button>
                        </div>
                        <div class="flex-grow flex flex-col gap-4 overflow-y-auto pr-2">
                            <div>
                                <h4 class="text-lg font-semibold text-gray-400 mb-2 text-left">Common Market</h4>
                                <div id="merchandise-grid-common" class="grid grid-cols-1 md:grid-cols-4 gap-4"></div>
                            </div>
                            <div>
                                <h4 class="text-lg font-semibold text-gray-400 mb-2 text-left">Specialty Stock</h4>
                                <div id="merchandise-grid-special" class="grid grid-cols-1 md:grid-cols-4 gap-4"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-span-1 bg-gray-900 rounded-lg p-4 flex flex-col">
                    <h3 class="text-2xl font-bold border-b-2 border-gray-700 pb-2 mb-4 text-left">Equipped</h3>
                    <div id="shop-equipped-gear-list" class="flex-grow overflow-y-auto space-y-3">
                        <p class="text-gray-500">Nothing equipped.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="collection-book-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="glass-panel rounded-2xl p-6 max-w-6xl w-full mx-auto h-[90vh] flex flex-col border border-white/20">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-4xl font-extrabold game-title">📚 Collection Book</h2>
                <div class="flex items-center gap-3">
                    <button id="view-last-run-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors">
                        View Last Run
                    </button>
                    <button id="clear-progress-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors flex items-center gap-2">
                        <span>🗑️</span>
                        Clear Progress
                    </button>
                    <button id="close-collection-book-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
                </div>
            </div>
            <div class="flex justify-between items-center border-b-2 border-gray-600 mb-4">
                 <div id="collection-book-tabs" class="flex items-center">
                </div>
            </div>
            <div id="collection-book-grid" class="grid grid-cols-5 grid-rows-2 gap-6 justify-items-center flex-grow p-4">
            </div>
            <div id="collection-pagination-controls" class="flex justify-center items-center mt-4 pt-4 border-t border-gray-700">
                <button id="collection-prev-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-l disabled:opacity-50 disabled:cursor-not-allowed">
                    &lt; Prev
                </button>
                <div id="collection-page-info" class="bg-gray-700 text-white py-2 px-4">Page 1 of 3</div>
                <button id="collection-next-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-r disabled:opacity-50 disabled:cursor-not-allowed">
                    Next &gt;
                </button>
            </div>
        </div>
    </div>

    <!-- Big Book Modal -->
    <div id="big-book-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="glass-panel w-[95vw] h-[90vh] max-w-7xl mx-auto rounded-2xl overflow-hidden flex flex-col">
            <!-- Header Section -->
            <div class="flex justify-between items-center p-6 border-b-2 border-gray-600 flex-shrink-0">
                <div class="flex items-center gap-4">
                    <h2 class="text-3xl font-bold text-white game-title">📚 The Big Book</h2>
                    <p class="text-gray-300">Every card you've ever collected</p>
                </div>
                <div class="flex items-center gap-4">
                    <div id="big-book-stats" class="text-sm text-gray-300">
                        <!-- Stats will be populated here -->
                    </div>
                    <button id="close-big-book-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
                </div>
            </div>

            <!-- Tabs Section -->
            <div class="flex justify-between items-center border-b-2 border-gray-600 flex-shrink-0">
                 <div id="big-book-tabs" class="flex items-center">
                </div>
            </div>

            <!-- Content Section - Takes remaining space -->
            <div class="flex-1 flex flex-col min-h-0">
                <div id="big-book-grid" class="grid grid-cols-5 gap-6 justify-items-center p-4 overflow-y-auto flex-1" style="grid-template-rows: repeat(2, minmax(0, 1fr));">
                </div>

                <!-- Pagination Controls - Always at bottom -->
                <div id="big-book-pagination-controls" class="flex justify-center items-center py-4 border-t border-gray-700 flex-shrink-0">
                    <button id="big-book-prev-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-l disabled:opacity-50 disabled:cursor-not-allowed">
                        &lt; Prev
                    </button>
                    <div id="big-book-page-info" class="bg-gray-700 text-white py-2 px-4">Page 1 of 1</div>
                    <button id="big-book-next-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-r disabled:opacity-50 disabled:cursor-not-allowed">
                        Next &gt;
                    </button>
                </div>
            </div>
        </div>
    </div>

     <div id="pack-odds-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-2xl shadow-2xl p-6 max-w-lg w-full mx-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 id="pack-odds-title" class="text-2xl font-extrabold text-yellow-400">Pack Odds</h2>
                <button id="close-pack-odds-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="pack-odds-content" class="text-gray-300 space-y-3">
            </div>
        </div>
    </div>
    
    <div id="card-detail-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div id="card-detail-content" class="relative">
             <button id="close-card-detail-btn" class="absolute -top-6 -right-6 text-5xl text-white hover:text-gray-300 z-10 bg-black bg-opacity-50 rounded-full w-12 h-12 flex items-center justify-center">&times;</button>
             <div id="card-detail-container">
             </div>
        </div>
    </div>

    <div id="clear-progress-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-2xl shadow-2xl p-8 text-center max-w-md mx-auto border-2 border-red-500">
            <div class="mb-6">
                <div class="text-6xl mb-4">⚠️</div>
                <h2 class="text-2xl font-bold text-red-400 mb-2">Clear All Progress?</h2>
                <p class="text-gray-300 text-sm mb-2">This will permanently delete:</p>
                <ul class="text-left text-gray-400 text-xs space-y-1 mb-4">
                    <li>• All cards in your collection</li>
                    <li>• All unlocked pack generations</li>
                    <li>• All unlocked pack licenses</li>
                    <li>• All settings and preferences</li>
                </ul>
                <p class="text-red-300 font-bold text-sm">This action cannot be undone!</p>
            </div>
            <div class="flex gap-4 justify-center">
                <button id="cancel-clear-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors">
                    Cancel
                </button>
                <button id="confirm-clear-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded transition-colors flex items-center gap-2">
                    <span>🗑️</span>
                    Clear
                </button>
            </div>
        </div>
    </div>

    <div id="info-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-2xl shadow-2xl p-6 max-w-2xl w-full mx-auto h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-extrabold text-blue-400">How to Play</h2>
                <button id="close-info-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="flex-grow overflow-y-auto text-gray-300 space-y-4 pr-4">
                <div>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2">The Basics</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li>Start a new run with $50. Your goal is to build the most valuable deck possible and grow your permanent collection.</li>
                        <li>Buy packs from the Mushroom Mart to get new cards.</li>
                        <li>For each card you pull, you must either <strong class="text-blue-400">Keep</strong> it for your deck or <strong class="text-green-400">Sell</strong> it for immediate cash.</li>
                        <li><strong class="text-red-400">Important:</strong> You must clear all opened cards from the field before you can buy another pack!</li>
                    </ul>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2">Ending a Run</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li>Your deck has a size limit (starts at 50). When it's full, the run ends.</li>
                        <li>The run also ends if you run out of money and can't afford any more packs.</li>
                        <li>You can also end a run at any time using the "End Run" button.</li>
                        <li>At the end of the run, your deck's value is calculated, and any new cards or upgrades are permanently added to your Collection's total value.</li>
                        <li>For every dollar of value in your final deck, you get one "roll" for a bonus reward card. The best new or upgraded card from these rolls is added to your permanent collection!</li>
                    </ul>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2">Burns & Sells</h3>
                    <ul class="list-disc list-inside space-y-2">
                         <li>You start each run with 1 Burn and 1 Sell. You can get more from certain cards or Merchandise.</li>
                        <li><strong class="text-red-500">Burning (🔥):</strong> Use a Burn on a card in your deck to remove it, freeing up space for a better card. <strong class="text-red-400">Warning:</strong> This also permanently removes the card from your Collection Book!</li>
                        <li><strong class="text-green-500">Selling ($):</strong> Use a Sell on a card in your deck to gain its cash value. <strong class="text-red-400">Warning:</strong> This also permanently removes the card from your Collection Book! Use it wisely to cash in on a valuable card you don't need for synergies.</li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2">The Mart & The Bazaar</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li>The main screen shows a rotating selection of available packs.</li>
                        <li>Click the "Full Shop" button to enter The Bazaar. Here you can buy:</li>
                        <li class="ml-4"><strong class="text-yellow-400">Pack Licenses:</strong> Permanent unlocks for new, more powerful packs that will then appear in the main Mart.</li>
                        <li class="ml-4"><strong class="text-purple-400">Merchandise:</strong> Powerful items that give you bonuses for your <strong class="text-red-400">current run only</strong>. These include playmats, deck boxes, and more!</li>
                    </ul>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2"><span id="unlocking-text" class="cursor-pointer hover:text-yellow-100 transition-colors">Unlocking</span> New Generations</h3>
                    <ul class="list-disc list-inside space-y-2">
                        <li>Your total Collection Value is shown in the top-left panel. This is the sum of the best version of every unique card you've ever kept.</li>
                        <li>When this value reaches certain milestones (e.g., $2,500), you will automatically unlock the next generation of cards (Gen 2, Gen 3, etc.), adding them to the card pool and unlocking new packs to buy.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div id="unlock-code-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-2xl shadow-2xl p-8 text-center max-w-lg mx-auto border-2 border-yellow-500">
            <div class="mb-6">
                <div class="text-4xl mb-4">🔓</div>
                <h2 class="text-2xl font-bold text-yellow-400 mb-4">Unlock Codes</h2>

                <!-- Active Unlocks Section -->
                <div id="active-unlocks-section" class="mb-6">
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Active Unlocks</h3>
                    <div id="active-unlocks-list" class="space-y-2 mb-4">
                        <!-- Active unlocks will be populated here -->
                    </div>
                </div>

                <!-- Enter New Code Section -->
                <div class="border-t border-gray-600 pt-4">
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Enter New Code</h3>
                    <input type="text" id="unlock-code-input" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-4 py-2 mb-4 focus:outline-none focus:border-yellow-500" placeholder="Enter code here..." maxlength="20">
                    <div id="unlock-code-message" class="text-sm text-gray-400 mb-4 min-h-[1.25rem]"></div>
                </div>
            </div>
            <div class="flex gap-4 justify-center">
                <button id="cancel-unlock-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors">
                    Cancel
                </button>
                <button id="enter-unlock-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-6 rounded transition-colors">
                    Enter
                </button>
            </div>
        </div>
    </div>

    <!-- Misprint Reward Modal -->
    <div id="misprint-reward-modal" class="fixed inset-0 z-50 items-center justify-center hidden modal-backdrop">
        <div class="glass-panel rounded-2xl p-8 text-center max-w-md mx-auto border-2 border-red-500/50">
            <div class="mb-6">
                <div class="text-4xl mb-4">⚠️</div>
                <h2 class="text-3xl font-bold text-red-400 game-title mb-4">Misprint Found!</h2>
                <p class="text-lg text-gray-300 mb-6">A rare misprint card has been added to your collection!</p>
            </div>

            <div class="flex flex-col items-center mb-6">
                <h3 class="text-xl font-bold mb-4 text-white">Your Misprint Card</h3>
                <div id="misprint-reward-card" class="w-[200px] flex justify-center">
                    <!-- Card will be inserted here -->
                </div>
            </div>

            <button id="misprint-reward-close-btn" class="btn-primary text-white font-bold py-3 px-8 rounded-xl text-lg transition-all">
                Awesome!
            </button>
        </div>
    </div>


<script src="cards.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- DOM ELEMENTS ---
    const moneyDisplay = document.getElementById('money-display');
    const deckValueDisplay = document.getElementById('deck-value-display');
    const deckCount = document.getElementById('deck-count');
    const burnCount = document.getElementById('burn-count');
    const sellCount = document.getElementById('sell-count');
    const deckGrid = document.getElementById('deck-grid-new');
    const deckSummaryCount = document.getElementById('deck-summary-count');
    const deckSummaryValue = document.getElementById('deck-summary-value');
    const deckSort = document.getElementById('deck-sort');
    const deckToggle = document.getElementById('deck-toggle');
    const deckToggleText = document.getElementById('deck-toggle-text');
    const deckToggleIcon = document.getElementById('deck-toggle-icon');
    const deckContent = document.getElementById('deck-content');
    const deckPagination = document.getElementById('deck-pagination');
    const deckPrevPage = document.getElementById('deck-prev-page');
    const deckNextPage = document.getElementById('deck-next-page');
    const deckPageInfo = document.getElementById('deck-page-info');
    const activeEffectsList = document.getElementById('active-effects-list');
    const equippedGearList = document.getElementById('equipped-gear-list');
    const packOpeningGrid = document.getElementById('pack-opening-grid');
    const shopGrid = document.getElementById('shop-grid');
    const endRunBtn = document.getElementById('end-run-btn');
    const gameOverModal = document.getElementById('game-over-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalMessage = document.getElementById('modal-message');
    const modalFinalValue = document.getElementById('modal-final-value');
    const modalNewCardsValue = document.getElementById('modal-new-cards-value');
    const modalCollectionValue = document.getElementById('modal-collection-value');
    const modalBestCard = document.getElementById('modal-best-card');
    const modalRewardCardContainer = document.getElementById('modal-reward-card-container');
    const modalRewardCard = document.getElementById('modal-reward-card');
    const modalProgressUpdate = document.getElementById('modal-progress-update');
    const modalNewRunBtn = document.getElementById('modal-new-run-btn');
    const modalClaimRewardBtn = document.getElementById('modal-claim-reward-btn');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    const unlockProgressBar = document.getElementById('unlock-progress-bar');
    const unlockProgressText = document.getElementById('unlock-progress-text');
    const unlockLabel = document.getElementById('unlock-label');
    const bodyBackground = document.getElementById('body-background');
    const elementalCountsIcons = document.getElementById('elemental-counts-icons');
    const runCounters = document.getElementById('run-counters');
    const toggleConditionIndicator = document.getElementById('toggle-condition');
    const toggleNewIndicator = document.getElementById('toggle-new');
    const toggleUpgradeIndicator = document.getElementById('toggle-upgrade');
    const sellAllBtn = document.getElementById('sell-all-btn');
    const autoplayBtn = document.getElementById('autoplay-btn');

    // Shop Modal Elements
    const enterShopBtn = document.getElementById('enter-shop-btn');
    const fullShopModal = document.getElementById('full-shop-modal');
    const closeShopBtn = document.getElementById('close-shop-btn');
    const packLicensingGrid = document.getElementById('pack-licensing-grid');
    const merchandiseGridCommon = document.getElementById('merchandise-grid-common');
    const merchandiseGridSpecial = document.getElementById('merchandise-grid-special');
    const restockMerchBtn = document.getElementById('restock-merch-btn');
    const shopEquippedGearList = document.getElementById('shop-equipped-gear-list');

    // Collection Book Elements
    const collectionBookBtn = document.getElementById('collection-book-btn');
    const collectionBookModal = document.getElementById('collection-book-modal');
    const closeCollectionBookBtn = document.getElementById('close-collection-book-btn');
    const collectionBookTabs = document.getElementById('collection-book-tabs');
    const collectionBookGrid = document.getElementById('collection-book-grid');
    const collectionPrevBtn = document.getElementById('collection-prev-btn');
    const collectionNextBtn = document.getElementById('collection-next-btn');
    const collectionPageInfo = document.getElementById('collection-page-info');

    // Big Book Elements
    const bigBookBtn = document.getElementById('big-book-btn');
    const bigBookModal = document.getElementById('big-book-modal');
    const closeBigBookBtn = document.getElementById('close-big-book-btn');
    const bigBookTabs = document.getElementById('big-book-tabs');
    const bigBookGrid = document.getElementById('big-book-grid');
    const bigBookStats = document.getElementById('big-book-stats');
    const bigBookPrevBtn = document.getElementById('big-book-prev-btn');
    const bigBookNextBtn = document.getElementById('big-book-next-btn');
    const bigBookPageInfo = document.getElementById('big-book-page-info');
    const viewLastRunBtn = document.getElementById('view-last-run-btn');
    const clearProgressBtn = document.getElementById('clear-progress-btn');

    // Clear Progress Modal Elements
    const clearProgressModal = document.getElementById('clear-progress-modal');
    const cancelClearBtn = document.getElementById('cancel-clear-btn');
    const confirmClearBtn = document.getElementById('confirm-clear-btn');

    // Pack Odds Modal Elements
    const packOddsModal = document.getElementById('pack-odds-modal');
    const closePackOddsBtn = document.getElementById('close-pack-odds-btn');
    const packOddsTitle = document.getElementById('pack-odds-title');
    const packOddsContent = document.getElementById('pack-odds-content');

    // Card Detail Modal Elements
    const cardDetailModal = document.getElementById('card-detail-modal');
    const closeCardDetailBtn = document.getElementById('close-card-detail-btn');
    const cardDetailContainer = document.getElementById('card-detail-container');

    // Info Modal Elements
    const infoBtn = document.getElementById('info-btn');
    const infoModal = document.getElementById('info-modal');
    const closeInfoBtn = document.getElementById('close-info-btn');
    const unlockingText = document.getElementById('unlocking-text');

    // Unlock Code Modal Elements
    const unlockCodeModal = document.getElementById('unlock-code-modal');
    const unlockCodeInput = document.getElementById('unlock-code-input');
    const unlockCodeMessage = document.getElementById('unlock-code-message');
    const activeUnlocksList = document.getElementById('active-unlocks-list');
    const activeUnlocksSection = document.getElementById('active-unlocks-section');
    const cancelUnlockBtn = document.getElementById('cancel-unlock-btn');
    const enterUnlockBtn = document.getElementById('enter-unlock-btn');

    // Misprint Reward Modal Elements
    const misprintRewardModal = document.getElementById('misprint-reward-modal');
    const misprintRewardCard = document.getElementById('misprint-reward-card');
    const misprintRewardCloseBtn = document.getElementById('misprint-reward-close-btn');
    
    // --- DEFINITIONS ---
    const UNLOCK_MILESTONES = { 'gen2': 2500, 'gen3': 25000 };

    // --- GAME STATE ---
    let state;
    let metaState;
    let PULL_RATE_CACHE = {};

    // Deck view state
    let deckViewState = {
        isCollapsed: false,
        sortBy: 'newest',
        currentPage: 1,
        cardsPerPage: 60
    };

    // --- UTILITY FUNCTIONS ---
    const formatPercent = (value) => {
        const percent = value * 100;
        if (percent === 0) return '0%';
        if (percent >= 10) return `${percent.toFixed(1)}%`;
        if (percent >= 0.1) return `${percent.toFixed(2)}%`;
        return `${percent.toFixed(3)}%`;
    };

    function formatMoney(value, includeSign = false) {
        const sign = value >= 0 && includeSign ? '+' : '';
        if (Math.abs(value) < 1 && Math.abs(value) > 0) {
            return `${sign}$${value.toFixed(2)}`;
        }
        return `${sign}$${(Math.round(value * 100) / 100).toLocaleString()}`;
    }

    // --- MAIN ---
    runPackSimulation('gen1', true);
    loadMetaState();
    startGame();

    // --- STATE MANAGEMENT ---
    function getDefaultState() {
        return { 
            money: 50, deck: [], deckValue: 0, 
            packSizeModifier: 0, shopDiscount: 0, luckBonus: 0, 
            valueModifiers: {}, flatValueBonus: 0, sellValueModifier: 0,
            maxDeckSize: 50,
            equippedMerchandise: { Playmat: null, Sleeves: null, 'Deck Box': null, Binder: null, Tool: null, Charm: null },
            currentShopMerchandise: { common: [], special: [] },
            licensedPacks: [],
            restockCost: 5,
            initialCollectionBookValue: 0,
            packsPurchased: {},
            conditionModifier: 0,
            flatCardValueBonus: 0,
            raritySellModifiers: {},
            burnsLeft: 1,
            bonusBurnsFromCards: 0, 
            cardsBurnedThisRun: 0,
            manualBurnsUsedThisRun: 0,
            sellsLeft: 1,
            bonusSellsFromCards: 0, 
            sellsUsedThisRun: 0,
            ephemeralLifespanBoost: 0,
            minimumCondition: 0,
            packConditions: {}, // Track condition for each pack type
            revealCondition: false,
            replacedCardsHistory: {},
            nextPackModifier: null,
            highlightedTypes: [],
            moMoneyEffectApplied: false,
            autoplayEnabled: false,
            autoplayInterval: null,
            runEnded: false,
            openedCards: [],
        };
    }

    function loadMetaState() {
        const saved = localStorage.getItem('elementalShroomsMeta');
        if (saved) {
            metaState = JSON.parse(saved);
        } else {
            metaState = {
                collectionBook: [],
                bigBook: [],
                unlockedGens: ['gen1'],
                unlockedLicenses: [],
                showConditionIndicator: true,
                showNewCardIndicator: true,
                showUpgradeCardIndicator: true,
                lastRunData: null, // Store last run results
            };
        }

        if (metaState.showConditionIndicator === undefined) metaState.showConditionIndicator = true;
        if (metaState.showNewCardIndicator === undefined) metaState.showNewCardIndicator = true;
        if (metaState.showUpgradeCardIndicator === undefined) metaState.showUpgradeCardIndicator = true;
        if (metaState.lastRunData === undefined) metaState.lastRunData = null;

        // Initialize unlock code effects
        if (metaState.unlockCodeEffects === undefined) {
            metaState.unlockCodeEffects = {
                bigDeckEnergy: false,
                moMoneyMoShrooms: false,
                maliciousShroom: false,
                premiumPrinters: false,
                supershinySparkly: false
            };
        }

        // Add new unlock codes to existing saves
        if (metaState.unlockCodeEffects.premiumPrinters === undefined) {
            metaState.unlockCodeEffects.premiumPrinters = false;
        }
        if (metaState.unlockCodeEffects.supershinySparkly === undefined) {
            metaState.unlockCodeEffects.supershinySparkly = false;
        }
        if (metaState.unlockCodeEffects.agent00Shroom === undefined) {
            metaState.unlockCodeEffects.agent00Shroom = false;
        }
        if (metaState.bigBook === undefined) {
            metaState.bigBook = [];
        }

        metaState.collectionBookView = {
            activeGen: 'gen1',
            currentPage: 1,
            cardsPerPage: 10,
        };

        if (!metaState.bigBookView) {
            metaState.bigBookView = {
                activeGen: 'gen1',
                currentPage: 1,
                cardsPerPage: 10,
            };
        }
        
        toggleConditionIndicator.checked = metaState.showConditionIndicator;
        toggleNewIndicator.checked = metaState.showNewCardIndicator;
        toggleUpgradeIndicator.checked = metaState.showUpgradeCardIndicator;
        
        updateUnlockProgressUI();
    }

    function saveMetaState() {
        const stateToSave = { ...metaState };
        delete stateToSave.collectionBookView;
        localStorage.setItem('elementalShroomsMeta', JSON.stringify(stateToSave));
        updateUnlockProgressUI();
    }

    // --- GAME LOGIC ---
    function startGame() {
        state = getDefaultState();
        state.initialCollectionBookValue = metaState.collectionBook.reduce((sum, card) => sum + getPersistentCardValue(card), 0);

        // Ensure run is not ended when starting
        state.runEnded = false;
        deckGrid.innerHTML = '';
        packOpeningGrid.innerHTML = '';
        gameOverModal.classList.add('hidden');
        gameOverModal.classList.remove('flex');

        // Apply unlock code effects
        if (metaState.unlockCodeEffects.bigDeckEnergy) {
            applyBigDeckEnergyEffect();
        }
        if (metaState.unlockCodeEffects.moMoneyMoShrooms) {
            applyMoMoneyMoShroomsEffect();
        }
        if (metaState.unlockCodeEffects.maliciousShroom) {
            applyMaliciousShroomEffect();
        }

        generateShopMerchandise();
        rerollAllPackConditions(); // Initialize pack conditions
        renderShop();
        renderFullShop();
        updateAutoplayButtonVisibility();
        recalculateState();
    }

    function renderShop() {
        shopGrid.innerHTML = '';
        const packsToShow = [...metaState.unlockedGens, ...metaState.unlockedLicenses];
        
        const groupedPacks = {};
        packsToShow.forEach(packKey => {
            const gen = packKey.substring(0, 4); 
            if (!groupedPacks[gen]) {
                groupedPacks[gen] = [];
            }
            groupedPacks[gen].push(packKey);
        });

        Object.keys(groupedPacks).sort().forEach(genKey => {
            const packKeys = groupedPacks[genKey];
            
            if (packKeys.length > 1) {
                const container = document.createElement('div');
                container.className = `bg-gray-700 p-3 rounded-xl flex flex-col`;
                
                const packDef = PACK_DEFINITIONS[packKeys[0]];
                container.innerHTML = `<h3 class="text-lg font-bold text-${packDef.color}-300 mb-2">${genKey.toUpperCase()} Packs</h3>`;
                
                const buttonWrapper = document.createElement('div');
                buttonWrapper.className = 'grid grid-cols-2 gap-2 flex-grow';
                
                packKeys.sort().forEach(pk => {
                    const pd = PACK_DEFINITIONS[pk];
                    const btn = document.createElement('button');
                    btn.dataset.pack = pk;
                    btn.className = `shop-pack-btn h-full relative bg-${pd.color}-600 hover:bg-${pd.color}-700 p-3 rounded-xl transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100 flex flex-col justify-between`;

                    // Check if magnifying glass is equipped
                    const hasMagnifyingGlass = state.equippedMerchandise?.Tool?.id === 't_r_glass';
                    let conditionIndicator = '';
                    if (hasMagnifyingGlass) {
                        const condition = getPackCondition(pk);
                        const conditionText = condition.toFixed(1);
                        const conditionColor = condition >= 7 ? 'green' : condition >= 4 ? 'yellow' : 'red';
                        conditionIndicator = `<div class="absolute top-1 left-1 bg-${conditionColor}-600 text-white text-xs font-bold px-1.5 py-0.5 rounded z-10">${conditionText}</div>`;
                    }

                    btn.innerHTML = `
                        ${conditionIndicator}
                        <div>
                            <p class="text-sm font-bold">${pd.name.replace('Gen 1 ', '').replace('Gen 2 ', '')}</p>
                            <p class="pack-price text-md font-semibold">$${pd.cost}</p>
                        </div>
                        <p class="text-xs text-${pd.color}-200">${pd.cards} Cards</p>
                        <div class="pack-odds-info absolute bottom-1 right-1 w-5 h-5 bg-gray-800 hover:bg-gray-600 rounded-full flex items-center justify-center text-xs font-bold cursor-pointer z-10">?</div>
                    `;
                    btn.addEventListener('click', () => buyPack(pk));
                    btn.querySelector('.pack-odds-info').addEventListener('click', (e) => {
                        e.stopPropagation();
                        showPackOddsModal(pk);
                    });
                    buttonWrapper.appendChild(btn);
                });

                container.appendChild(buttonWrapper);
                shopGrid.appendChild(container);

            } else {
                const packKey = packKeys[0];
                const packDef = PACK_DEFINITIONS[packKey];
                if (!packDef) return;
                const btn = document.createElement('button');
                btn.dataset.pack = packKey;
                btn.className = `shop-pack-btn relative bg-${packDef.color}-600 hover:bg-${packDef.color}-700 p-6 rounded-xl transition-transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100`;

                // Check if magnifying glass is equipped
                const hasMagnifyingGlass = state.equippedMerchandise?.Tool?.id === 't_r_glass';
                let conditionIndicator = '';
                if (hasMagnifyingGlass) {
                    const condition = getPackCondition(packKey);
                    const conditionText = condition.toFixed(1);
                    const conditionColor = condition >= 7 ? 'green' : condition >= 4 ? 'yellow' : 'red';
                    conditionIndicator = `<div class="absolute top-2 left-2 bg-${conditionColor}-600 text-white text-sm font-bold px-2 py-1 rounded z-10">${conditionText}</div>`;
                }

                btn.innerHTML = `
                    ${conditionIndicator}
                    <p class="text-xl font-bold">${packDef.name}</p>
                    <p class="pack-price text-lg font-semibold">$${packDef.cost}</p>
                    <p class="text-sm text-${packDef.color}-200">${packDef.cards} Cards</p>
                    <div class="pack-odds-info absolute bottom-2 right-2 w-6 h-6 bg-gray-700 hover:bg-gray-600 rounded-full flex items-center justify-center text-sm font-bold cursor-pointer z-10">?</div>
                `;
                btn.addEventListener('click', () => buyPack(packKey));
                btn.querySelector('.pack-odds-info').addEventListener('click', (e) => {
                    e.stopPropagation();
                    showPackOddsModal(packKey);
                });
                shopGrid.appendChild(btn);
            }
        });
    }

    function buyPack(packKey) {
        if (packOpeningGrid.children.length > 0) {
            packOpeningGrid.classList.add('ring-2', 'ring-red-500');
            setTimeout(() => packOpeningGrid.classList.remove('ring-2', 'ring-red-500'), 500);
            return;
        }

        if (state.deck.length >= state.maxDeckSize) {
            console.log("Deck is full!");
            return;
        }

        const packDef = PACK_DEFINITIONS[packKey];
        const numPurchased = state.packsPurchased[packKey] || 0;
        const costIncrease = (numPurchased * (numPurchased + 1) / 2) * 0.01;
        let cost = (packDef.cost + costIncrease) * (1 - state.shopDiscount);

        if ((state.packsPurchased['total'] || 0) === 0 && metaState.collectionBook.some(c => c.id === 196)) {
            cost = 0;
        }
        
        if (state.money >= cost) {
            state.money -= cost;
            state.packsPurchased[packKey] = (state.packsPurchased[packKey] || 0) + 1;
            state.packsPurchased['total'] = (state.packsPurchased['total'] || 0) + 1;
            
            const newPack = generatePack(packKey);
            
            if (state.nextPackModifier) {
                state.nextPackModifier = null;
            }

            displayOpenedCards(newPack);

            // Reroll all pack conditions after opening any pack
            rerollAllPackConditions();
            renderShop(); // Update condition indicators

            recalculateState();
        }
    }

    function generateCard(cardPool, baseRarity, typeBiasInfo, packCondition, boostedFinishes = false, simState = null) {
        const currentRunState = simState || state;
        const { typeBias, typeBiasAmount, typeReduction, typeReductionAmount } = typeBiasInfo;

        let potentialTypes = Object.values(TYPES);
        if (typeReduction && Math.random() < typeReductionAmount) {
             potentialTypes = potentialTypes.filter(t => t !== typeReduction);
        }
        
        let cardType;
        if(typeBiasInfo.forceType) {
             cardType = typeBiasInfo.forceType;
        } else {
             cardType = (typeBias && Math.random() < typeBiasAmount) ? typeBias : potentialTypes[Math.floor(Math.random() * potentialTypes.length)];
        }

        const possibleCards = cardPool.filter(c => c.baseRarity === baseRarity && (Array.isArray(c.type) ? c.type.includes(cardType) : c.type === cardType));
        let cardTemplate = possibleCards.length > 0 
            ? possibleCards[Math.floor(Math.random() * possibleCards.length)] 
            : cardPool.filter(c => c.baseRarity === baseRarity)[0] || cardPool[0];

        let cardCondition = packCondition - 1 + Math.random() * 2;
        cardCondition += currentRunState.conditionModifier;
        cardCondition = Math.max(currentRunState.minimumCondition, cardCondition);

        // Apply Premium Printers effect - all cards are Gem Mint (10.0)
        if (metaState.unlockCodeEffects.premiumPrinters) {
            cardCondition = 10.0;
        }

        cardCondition = Math.max(0.1, Math.min(11, cardCondition));
        cardCondition = parseFloat(cardCondition.toFixed(1));

        const finishes = generateFinishes(baseRarity, boostedFinishes, simState);

        const card = { ...cardTemplate, finishes: finishes, condition: cardCondition, keeps: 0 };

        // If card has misprint finish, generate and store the errors
        if (finishes.some(f => f === FINISHES.MISPRINT)) {
            card.misprintErrors = generateMisprintErrors(card);
        }

        return card;
    }

    function getPackCondition(packKey) {
        // Get or generate pack condition
        if (!state.packConditions[packKey]) {
            state.packConditions[packKey] = 1 + ((Math.random() + Math.random() + Math.random()) / 3) * 9;
        }
        return state.packConditions[packKey];
    }

    function rerollAllPackConditions() {
        // Reroll conditions for all available packs
        state.packConditions = {};
        Object.keys(PACK_DEFINITIONS).forEach(packKey => {
            if (metaState.unlockedGens.includes(packKey) || metaState.unlockedLicenses.includes(packKey)) {
                state.packConditions[packKey] = 1 + ((Math.random() + Math.random() + Math.random()) / 3) * 9;
            }
        });
    }

    function generatePack(packKey, simState = null) {
        const packDef = PACK_DEFINITIONS[packKey];
        const pack = [];
        const currentRunState = simState || state;
        let numCards = packDef.cards + currentRunState.packSizeModifier;
        numCards = Math.max(1, Math.min(10, numCards)); // Limit pack size to maximum of 10 cards

        const packCondition = simState ? (1 + ((Math.random() + Math.random() + Math.random()) / 3) * 9) : getPackCondition(packKey);

        const playmat = currentRunState.equippedMerchandise?.Playmat;
        const typeBiasInfo = {
            typeBias: null, typeBiasAmount: 0,
            typeReduction: null, typeReductionAmount: 0,
            forceType: null,
        };
        
        if (currentRunState.nextPackModifier && Math.random() < currentRunState.nextPackModifier.chance) {
            typeBiasInfo.forceType = currentRunState.nextPackModifier.type;
        } else if (packDef.elementalFocus) {
            typeBiasInfo.forceType = Object.values(TYPES).filter(t => t !== TYPES.WILD)[Math.floor(Math.random() * (Object.keys(TYPES).length -1))];
        } else if (playmat && playmat.effect.type === 'TYPE_BIAS_DUAL') {
            typeBiasInfo.typeBias = playmat.effect.payload.typeUp;
            typeBiasInfo.typeBiasAmount = playmat.effect.payload.upAmount;
            typeBiasInfo.typeReduction = playmat.effect.payload.typeDown;
            typeBiasInfo.typeReductionAmount = playmat.effect.payload.downAmount;
        }
        
        let raritySlots = [];
        const boosted = (packKey === 'gen1-rare' || packKey === 'gen2-rare');

        if (boosted) {
             raritySlots = [
                Math.random() < 0.5 ? BASE_RARITIES.COMMON : BASE_RARITIES.UNCOMMON,
                Math.random() < 0.5 ? BASE_RARITIES.COMMON : BASE_RARITIES.UNCOMMON,
                Math.random() < 0.5 ? BASE_RARITIES.COMMON : BASE_RARITIES.UNCOMMON,
                (() => { let r = Math.random(); return r < 0.01 ? BASE_RARITIES.SECRET_RARE : r < 0.10 ? BASE_RARITIES.ULTRA_RARE : r < 0.90 ? BASE_RARITIES.RARE : BASE_RARITIES.UNCOMMON; })(),
                (() => { let r = Math.random(); return r < 0.05 ? BASE_RARITIES.SECRET_RARE : r < 0.55 ? BASE_RARITIES.ULTRA_RARE : BASE_RARITIES.RARE; })()
            ];
        } else {
            raritySlots = [
                BASE_RARITIES.COMMON, BASE_RARITIES.COMMON, BASE_RARITIES.COMMON,
                (() => { let r = Math.random(); return r < 0.01 ? BASE_RARITIES.ULTRA_RARE : r < 0.1 ? BASE_RARITIES.RARE : BASE_RARITIES.UNCOMMON; })(),
                (() => { let r = Math.random(); return r < 0.01 ? BASE_RARITIES.SECRET_RARE : r < 0.1 ? BASE_RARITIES.ULTRA_RARE : BASE_RARITIES.RARE; })()
            ];
        }

        for (let i = 5; i < Math.min(10, packDef.cards + currentRunState.packSizeModifier); i++) {
            const randRarity = Math.random() - (packDef.rarityBias || 0);
            let baseRarity;
            if (randRarity < 0.01) baseRarity = BASE_RARITIES.SECRET_RARE;
            else if (randRarity < 0.05) baseRarity = BASE_RARITIES.ULTRA_RARE;
            else if (randRarity < 0.15) baseRarity = BASE_RARITIES.RARE;
            else if (randRarity < 0.40) baseRarity = BASE_RARITIES.UNCOMMON;
            else baseRarity = BASE_RARITIES.COMMON;
            raritySlots.push(baseRarity);
        }
        
        const finalRaritySlots = raritySlots.slice(0, numCards);

        for(const rarity of finalRaritySlots) {
             pack.push(generateCard(packDef.cardPool, rarity, typeBiasInfo, packCondition, boosted, simState));
        }

        const leechSpore = pack.find(c => c.id === 171);
        if (leechSpore) {
            pack.forEach(card => {
                if (card !== leechSpore && Math.random() < 0.25) {
                    card.condition = Math.max(0.1, card.condition - 1.0);
                    card.condition = parseFloat(card.condition.toFixed(1));
                }
            });
        }

        return pack;
    }

    function generateFinishes(baseRarity, boosted = false, simState = null) {
        let finishes = [];
        const currentRunState = simState || state;
        let luck = currentRunState.luckBonus;
        if (boosted) {
            luck += 1.0;
        }

        // Apply Super Shiny Sparkly effect - 100x more likely special finishes
        if (metaState.unlockCodeEffects.supershinySparkly) {
            luck += 99.0; // 100x total = 1x base + 99x bonus
        }

        switch(baseRarity) {
            case BASE_RARITIES.COMMON:
                if (Math.random() < 0.001 * (1 + luck)) finishes.push(FINISHES.HOLO);
                if (Math.random() < 0.0001 * (1 + luck)) finishes.push(FINISHES.PRISMATIC);
                if (Math.random() < 0.00001 * (1 + luck)) finishes.push(FINISHES.FULL_ART);
                break;
            case BASE_RARITIES.UNCOMMON:
                if (Math.random() < 0.01 * (1 + luck)) finishes.push(FINISHES.HOLO);
                if (Math.random() < 0.001 * (1 + luck)) finishes.push(FINISHES.PRISMATIC);
                if (Math.random() < 0.0001 * (1 + luck)) finishes.push(FINISHES.FULL_ART);
                break;
            case BASE_RARITIES.RARE:
                if (Math.random() < 0.1 * (1 + luck)) finishes.push(FINISHES.HOLO);
                if (Math.random() < 0.01 * (1 + luck)) finishes.push(FINISHES.PRISMATIC);
                if (Math.random() < 0.001 * (1 + luck)) finishes.push(FINISHES.FULL_ART);
                break;
            case BASE_RARITIES.ULTRA_RARE:
                if (Math.random() < 0.5 * (1 + luck)) finishes.push(FINISHES.HOLO);
                if (Math.random() < 0.1 * (1 + luck)) finishes.push(FINISHES.PRISMATIC);
                if (Math.random() < 0.01 * (1 + luck)) finishes.push(FINISHES.FULL_ART);
                break;
            case BASE_RARITIES.SECRET_RARE:
                finishes.push(FINISHES.HOLO);
                if (Math.random() < 0.1 * (1 + luck)) finishes.push(FINISHES.PRISMATIC);
                if (Math.random() < 0.01 * (1 + luck)) finishes.push(FINISHES.FULL_ART);
                break;
        }

        // Check for misprint - flat 0.1% chance, unaffected by luck
        const misprintRoll = Math.random();
        if (misprintRoll < 0.001) {
            console.log(`MISPRINT GENERATED! Roll: ${misprintRoll}`);
            finishes.push(FINISHES.MISPRINT);
        }

        if (finishes.length === 0) {
            finishes.push(FINISHES.STANDARD);
        }
        return finishes;
    }

    function keepCard(card, cardEl, buttonContainer) {
        if (state.deck.length >= state.maxDeckSize) {
            buttonContainer.innerHTML = `<p class="col-span-2 text-center text-red-500 text-sm py-2">Deck Full!</p>`;
            setTimeout(() => {
                if(buttonContainer.parentElement) {
                    const keepValue = calculateCardValue(card, [...state.deck, card], state);
                    const sellValue = getSellValue(card);
                    buttonContainer.innerHTML = `
                        <button class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-2 px-3 rounded transition-colors">Keep (${formatMoney(keepValue)})</button>
                        <button class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-2 px-3 rounded transition-colors">Sell (${formatMoney(sellValue)})</button>
                    `;
                    buttonContainer.querySelector('.bg-blue-600').onclick = () => keepCard(card, cardEl, buttonContainer);
                    buttonContainer.querySelector('.bg-green-600').onclick = () => sellCard(card, cardEl, buttonContainer);
                }
            }, 2000);
            return;
        }

        if (card.effect) {
            switch(card.effect.type) {
                case 'ADD_BURNS':
                    state.bonusBurnsFromCards += card.effect.payload.amount;
                    break;
                case 'ADD_SELLS':
                    state.bonusSellsFromCards += card.effect.payload.amount;
                    break;
            }
        }

        state.deck.forEach(c => {
            if (c.effect?.type === 'FIRST_CARD_MODIFIER' && (c.chargesUsed || 0) < c.effect.payload.count) {
                card.condition = Math.min(11, card.condition + c.effect.payload.condition);
                card.condition = parseFloat(card.condition.toFixed(1));
                c.chargesUsed = (c.chargesUsed || 0) + 1;
            }
        });
        
        state.deck.forEach(c => {
            if (c.effect?.type === 'EPHEMERAL') {
                c.keeps = (c.keeps || 0) + 1;
            }
        });
        const cardsToBurn = state.deck.filter(c => c.effect?.type === 'EPHEMERAL' && c.keeps >= (c.effect.payload.lifespan + state.ephemeralLifespanBoost));
        if(cardsToBurn.length > 0) {
            cardsToBurn.forEach(burnedCard => {
                const cardIndex = state.deck.findIndex(c => c === burnedCard);
                burnCard(cardIndex, true); 
            })
        }
        
        if (card.effect?.type === 'BURN_SYNERGY_MONEY' && !card.effectApplied) {
            const moneyGained = state.cardsBurnedThisRun * card.effect.payload.amount;
            state.money += moneyGained;
            card.effectApplied = true;
        }

        if (card.effect?.type === 'PACK_MODIFIER' && !card.effectUsed) {
            state.nextPackModifier = card.effect.payload;
            card.effectUsed = true;
        }

        if (card.effect?.type === 'VALUE_OVER_TIME') {
            card.keptAtPackCount = state.packsPurchased['total'] || 0;
        }
        
        state.deck.push(card);
        cardEl.parentElement.remove(); // Remove the card-with-buttons container
        updateCollectionBook(card);
        
        if (card.effect?.type === 'RISK_REWARD' && card.effect.payload.burn_chance) {
            if (Math.random() < card.effect.payload.burn_chance) {
                const burnableCards = state.deck.filter(c => c !== card);
                if (burnableCards.length > 0) {
                    const cardToBurn = burnableCards[Math.floor(Math.random() * burnableCards.length)];
                    const cardIndexToBurn = state.deck.findIndex(c => c === cardToBurn);
                    if (cardIndexToBurn > -1) {
                        burnCard(cardIndexToBurn, true);
                    }
                }
            }
        }

        recalculateState();

        if (packOpeningGrid.children.length === 0) {
            sellAllBtn.classList.add('hidden');
        }

        if (state.deck.length >= state.maxDeckSize) {
            endRun('deckFull');
        }
    }

    function updateCollectionBook(newCard) {
        const existingCardIndex = metaState.collectionBook.findIndex(c => c.id === newCard.id);
        const newCardValue = getPersistentCardValue(newCard);

        if (existingCardIndex === -1) {
            metaState.collectionBook.push(newCard);
        } else {
            const existingCard = metaState.collectionBook[existingCardIndex];
            const existingCardValue = getPersistentCardValue(existingCard);
            if (newCardValue > existingCardValue) {
                if (!state.replacedCardsHistory[existingCard.id]) {
                    state.replacedCardsHistory[existingCard.id] = [];
                }
                state.replacedCardsHistory[existingCard.id].push(existingCard);

                metaState.collectionBook[existingCardIndex] = newCard;
            }
        }

        // Always add to Big Book (tracks every version)
        updateBigBook(newCard);

        saveMetaState();

        // Check for new unlocks immediately
        checkForNewUnlocks();

        // Debug: Log Big Book size
        console.log(`Big Book now has ${metaState.bigBook.length} entries`);
        const activeGen = metaState.bigBookView.activeGen;
        const cardsInGen = metaState.bigBook.filter(card => {
            const cardDef = CARD_GENERATIONS[activeGen].find(c => c.id === card.id);
            return cardDef !== undefined;
        });
        console.log(`Cards in ${activeGen}: ${cardsInGen.length}`);
        console.log(`Pages needed: ${Math.ceil(cardsInGen.length / metaState.bigBookView.cardsPerPage)}`);
    }

    function updateBigBook(newCard) {
        const cardId = newCard.id;

        // Create a unique key for this finish combination
        const finishCombinationKey = newCard.finishes
            .map(f => f.name)
            .sort() // Sort to ensure consistent ordering
            .join('+');

        console.log(`Processing card ${newCard.name} (ID: ${cardId}) with finish combination: ${finishCombinationKey}`);

        // Find existing card with same ID and exact finish combination
        const existingIndex = metaState.bigBook.findIndex(card => {
            if (card.id !== cardId) return false;

            // Compare finish combinations
            const existingFinishKey = card.finishes
                .map(f => f.name)
                .sort()
                .join('+');

            return existingFinishKey === finishCombinationKey;
        });

        if (existingIndex === -1) {
            // No existing card with this exact finish combination, add new entry
            const bigBookCard = {
                ...newCard,
                finishes: [...newCard.finishes], // Keep all finishes
                bigBookId: `${cardId}_${finishCombinationKey}_${Date.now()}`,
                collectedAt: Date.now()
            };
            metaState.bigBook.push(bigBookCard);
            console.log(`Added new Big Book entry for ${newCard.name} with ${finishCombinationKey}`);
        } else {
            // Compare conditions and keep the better one
            const existingCard = metaState.bigBook[existingIndex];
            if (newCard.condition > existingCard.condition) {
                // Replace with better condition version
                const bigBookCard = {
                    ...newCard,
                    finishes: [...newCard.finishes], // Keep all finishes
                    bigBookId: `${cardId}_${finishCombinationKey}_${Date.now()}`,
                    collectedAt: Date.now()
                };
                metaState.bigBook[existingIndex] = bigBookCard;
                console.log(`Updated Big Book entry for ${newCard.name} with ${finishCombinationKey} (better condition: ${newCard.condition})`);
            } else {
                console.log(`Kept existing Big Book entry for ${newCard.name} with ${finishCombinationKey} (condition ${existingCard.condition} >= ${newCard.condition})`);
            }
        }

        // Sort by card ID, then by total finish value, then by condition
        metaState.bigBook.sort((a, b) => {
            if (a.id !== b.id) {
                return a.id - b.id;
            }

            // Calculate total finish multiplier for sorting
            const aTotalFinishValue = a.finishes.reduce((sum, f) => sum + f.multiplier, 0);
            const bTotalFinishValue = b.finishes.reduce((sum, f) => sum + f.multiplier, 0);

            if (aTotalFinishValue !== bTotalFinishValue) {
                return aTotalFinishValue - bTotalFinishValue;
            }

            return a.condition - b.condition;
        });
    }

    function getSellValue(card) {
        let moneyGained = calculateCardValue(card, state.deck, state);
        let sellModifier = 1 + state.sellValueModifier;

        if(state.raritySellModifiers[card.baseRarity.name]) {
            sellModifier += state.raritySellModifiers[card.baseRarity.name];
        }
        return moneyGained * Math.max(0.1, sellModifier); // Minimum 10% sell value
    }

    function sellCard(card, cardEl, buttonContainer) {
        state.money += getSellValue(card);
        cardEl.parentElement.remove(); // Remove the card-with-buttons container

        if (packOpeningGrid.children.length === 0) {
            sellAllBtn.classList.add('hidden');
        }
        updateUI();
    }

    function sellAllOpenedCards() {
        const cardWithButtonsElements = Array.from(packOpeningGrid.querySelectorAll('.card-with-buttons'));
        if (cardWithButtonsElements.length === 0) return;
        cardWithButtonsElements.forEach(cardWithButtonsEl => {
            const cardEl = cardWithButtonsEl.querySelector('.card');
            const buttonContainer = cardWithButtonsEl.querySelector('.card-buttons');
            if (cardEl && cardEl.cardData && buttonContainer) {
                sellCard(cardEl.cardData, cardEl, buttonContainer);
            }
        });
    }

    function recalculateState() {
        // 1. Reset transient modifiers
        state.packSizeModifier = 0;
        state.shopDiscount = 0;
        state.luckBonus = 0;
        state.valueModifiers = {};
        state.flatValueBonus = 0;

        // Reset base values but preserve unlock code effects
        let baseDeckSize = 50;
        let baseSellModifier = 0;

        // Apply unlock code effects to base values
        if (metaState.unlockCodeEffects.bigDeckEnergy) {
            baseDeckSize = 100; // Double base deck size
        }
        if (metaState.unlockCodeEffects.maliciousShroom) {
            baseDeckSize = Math.floor(baseDeckSize / 2); // Half deck size
            baseSellModifier -= 0.5; // -50% sell value
        }
        if (metaState.unlockCodeEffects.moMoneyMoShrooms) {
            baseSellModifier += 1.0; // +100% sell value
        }

        state.maxDeckSize = baseDeckSize;
        state.sellValueModifier = baseSellModifier;
        state.conditionModifier = 0;
        state.flatCardValueBonus = 0;
        state.raritySellModifiers = {};
        state.minimumCondition = 0;
        let totalBonusSellsFromMerch = 0;

        activeEffectsList.innerHTML = '';
        equippedGearList.innerHTML = '';
        bodyBackground.className = 'bg-gray-900 text-white p-4 sm:p-8 transition-colors duration-500'; 

        // 2. Apply merchandise effects
        for(const type in state.equippedMerchandise) {
            const item = state.equippedMerchandise[type];
            if (item) {
                const gearContainer = document.createElement('div');
                gearContainer.className = 'tooltip-container';
                const gearEl = document.createElement('p');
                gearEl.className = 'bg-gray-700 p-1 rounded';
                gearEl.textContent = `${item.name}`;
                const tooltipEl = document.createElement('div');
                tooltipEl.className = 'tooltip';
                tooltipEl.innerHTML = `<div class="bg-gray-800 border border-gray-600 rounded-lg p-3 text-center text-sm"><p class="font-bold">${item.name}</p><p class="text-xs text-gray-400">${item.rarity.name} ${item.type}</p><p class="italic mt-2">${item.desc}</p></div>`;
                
                gearContainer.appendChild(gearEl);
                gearContainer.appendChild(tooltipEl);
                equippedGearList.appendChild(gearContainer);

                if (item.theme) {
                    bodyBackground.classList.remove('bg-gray-900');
                    bodyBackground.classList.add(item.theme);
                }
                switch (item.effect.type) {
                    case 'MAX_COLLECTION_INCREASE':
                        let deckSizeBonus = item.effect.payload.amount;
                        if (metaState.unlockCodeEffects.bigDeckEnergy) {
                            deckSizeBonus *= 2; // Double deck size buffs
                        }
                        state.maxDeckSize += deckSizeBonus;
                        break;
                    case 'LUCK_INCREASE': state.luckBonus += item.effect.payload.percent; break;
                    case 'CONDITION_INCREASE': state.conditionModifier += item.effect.payload.amount; break;
                    case 'FLAT_CARD_VALUE_INCREASE': state.flatCardValueBonus += item.effect.payload.amount; break;
                    case 'RARITY_SELL_MODIFIER': 
                        state.raritySellModifiers[item.effect.payload.rarity.name] = item.effect.payload.percent;
                        break;
                    case 'ADD_SELLS': totalBonusSellsFromMerch += item.effect.payload.amount; break;
                    case 'MINIMUM_CONDITION': state.minimumCondition = Math.max(state.minimumCondition, item.effect.payload.amount); break;
                }
            }
        }
        if (Object.values(state.equippedMerchandise).every(i => i === null)) {
            equippedGearList.innerHTML = '<p class="text-gray-500">None.</p>';
        }
        
        // 3. Apply card effects
        state.deck.forEach(card => {
            if (card.effect?.type === 'MIRROR_EFFECT') {
                const otherCards = state.deck.filter(c => c.id !== card.id && c.effect && c.effect.type !== 'MIRROR_EFFECT');
                if (otherCards.length > 0) {
                    const cardToCopy = otherCards[card.id % otherCards.length]; 
                    card.copiedEffect = cardToCopy.effect;
                    card.copiedDesc = cardToCopy.desc;
                } else {
                    delete card.copiedEffect;
                    delete card.copiedDesc;
                }
            }
        });

        state.deck.forEach(card => {
            const effect = card.copiedEffect || card.effect;
            if (!effect) return;

            // Handle ephemeral stat boosts
            if (effect.type === 'EPHEMERAL' && effect.payload.luck) {
                state.luckBonus += effect.payload.luck;
            }

            switch (effect.type) {
                case 'PACK_SIZE_INCREASE': state.packSizeModifier += effect.payload.amount; break;
                case 'SHOP_DISCOUNT': state.shopDiscount += effect.payload.percent; break;
                case 'LUCK_INCREASE': state.luckBonus += effect.payload.percent; break;
                case 'FLAT_VALUE_INCREASE': state.flatValueBonus += effect.payload.amount; break;
                case 'SELL_VALUE_INCREASE': state.sellValueModifier += effect.payload.percent; break;
                case 'RISK_REWARD': 
                    state.luckBonus += effect.payload.luck_percent || 0;
                    state.sellValueModifier -= effect.payload.sell_penalty_percent || 0;
                    state.packSizeModifier -= effect.payload.pack_size_penalty || 0;
                    break;
                case 'VALUE_MODIFIER': 
                    if (!state.valueModifiers[effect.payload.type.name]) state.valueModifiers[effect.payload.type.name] = 0;
                    state.valueModifiers[effect.payload.type.name] += effect.payload.amount;
                    break;
                case 'MINIMUM_CONDITION': state.minimumCondition = Math.max(state.minimumCondition, effect.payload.amount); break;
            }
        });
        
        state.burnsLeft = 1 + state.bonusBurnsFromCards - state.manualBurnsUsedThisRun;
        state.sellsLeft = 1 + state.bonusSellsFromCards + totalBonusSellsFromMerch - state.sellsUsedThisRun;

        // 4. Render Active Effects list
        if (state.packSizeModifier !== 0) {
            const basePackSize = 5; // Standard pack size
            const modifiedPackSize = basePackSize + state.packSizeModifier;
            const actualPackSize = Math.min(10, modifiedPackSize);
            const effectText = `${state.packSizeModifier > 0 ? '+' : ''}${state.packSizeModifier} card(s) per pack`;
            const cappedText = modifiedPackSize > 10 ? ' (capped at 10)' : '';
            addEffectToList(effectText + cappedText);
        }
        if (state.shopDiscount > 0) addEffectToList(`${(state.shopDiscount * 100).toFixed(0)}% cheaper packs`);
        if (state.luckBonus > 0) addEffectToList(`+${(state.luckBonus * 100).toFixed(0)}% Special Finish Chance`);
        if (state.flatValueBonus > 0) addEffectToList(`+${formatMoney(state.flatValueBonus)} to total deck value`);
        if (state.sellValueModifier !== 0) {
            const sign = state.sellValueModifier > 0 ? '+' : '';
            addEffectToList(`${sign}${(state.sellValueModifier * 100).toFixed(0)}% money from selling`);
        }
        Object.keys(state.valueModifiers).forEach(typeName => {
            addEffectToList(`+${formatMoney(state.valueModifiers[typeName])} to all ${typeName} shrooms`);
        });
        if(state.conditionModifier > 0) addEffectToList(`+${state.conditionModifier.toFixed(1)} to card conditions`);
        if(state.flatCardValueBonus > 0) addEffectToList(`+${formatMoney(state.flatCardValueBonus)} to each card's value`);
        if(state.minimumCondition > 0) addEffectToList(`Min condition for cards is ${state.minimumCondition.toFixed(1)}`);
        Object.keys(state.raritySellModifiers).forEach(rarityName => {
            addEffectToList(`+${state.raritySellModifiers[rarityName] * 100}% sell value for ${rarityName}s`);
        });

        // Add unlock code effects
        if (metaState.unlockCodeEffects.bigDeckEnergy) {
            addEffectToList('🚀 Big Deck Energy: Double deck size & deck size buffs');
        }
        if (metaState.unlockCodeEffects.moMoneyMoShrooms) {
            addEffectToList('💰 Mo Money Mo Shrooms: Double starting money & +100% sell value');
        }
        if (metaState.unlockCodeEffects.maliciousShroom) {
            addEffectToList('☠️ Malicious Shroom: Hard mode activated');
        }
        if (metaState.unlockCodeEffects.premiumPrinters) {
            addEffectToList('💎 Premium Printers: All cards are Gem Mint condition');
        }
        if (metaState.unlockCodeEffects.supershinySparkly) {
            addEffectToList('✨ Super Shiny Sparkly: 100x more likely special finishes');
        }
        if (metaState.unlockCodeEffects.agent00Shroom) {
            addEffectToList('🤖 Agent 00 Shroom: Autoplay button unlocked');
        }

        if (activeEffectsList.children.length === 0) {
             activeEffectsList.innerHTML = state.deck.length === 0 ? '<p class="text-gray-500">None yet!</p>' : '<p class="text-gray-500">None.</p>';
        }
        
        // 5. Calculate total deck value & update UI
        state.deckValue = state.deck.reduce((sum, card) => sum + getCardValue(card), 0) + state.flatValueBonus;
        
        const counts = {};
        Object.values(TYPES).forEach(t => counts[t.name] = 0);
        state.deck.forEach(card => {
            if(Array.isArray(card.type)) {
                card.type.forEach(t => counts[t.name]++);
            } else if (card.type === TYPES.WILD) {
                Object.values(TYPES).forEach(t => { if(t !== TYPES.WILD) counts[t.name]++; });
            }
            else {
                counts[card.type.name]++;
            }
        });
        elementalCountsIcons.innerHTML = Object.keys(counts).map(k => {
            const type = Object.values(TYPES).find(t => t.name === k);
            const activeClass = state.highlightedTypes.includes(type.name) ? 'active' : '';
            return `<div data-type="${type.name}" class="elemental-icon ${activeClass} flex items-center gap-1 text-lg cursor-pointer transition-transform"><span class="text-2xl">${type.icon}</span> <span class="font-bold">${counts[k]}</span></div>`;
        }).join('');

        runCounters.innerHTML = `
            <div title="Packs Bought"><span class="font-bold">${state.packsPurchased['total'] || 0}</span> 📦</div>
            <div title="Burns Used"><span class="font-bold">${state.manualBurnsUsedThisRun}</span> 🔥</div>
            <div title="Sells Used"><span class="font-bold">${state.sellsUsedThisRun}</span> 💲</div>
        `;

        updateDeckboxBackground();
        updateSleevesBackground();
        updateBinderBackground();
        renderDeck();
        updateUI();

        packOpeningGrid.querySelectorAll('.card-with-buttons').forEach(cardWithButtonsEl => {
            const cardEl = cardWithButtonsEl.querySelector('.card');
            if (cardEl && cardEl.cardData) {
                const cardData = cardEl.cardData;
                const keepValue = calculateCardValue(cardData, [...state.deck, cardData], state);
                const sellValue = getSellValue(cardData);
                // Base value should be collection value (rarity + condition + finish only)
                const baseValue = getPersistentCardValue(cardData);

                const keepBtn = cardWithButtonsEl.querySelector('.keep-btn');
                const sellBtn = cardWithButtonsEl.querySelector('.sell-btn');
                const valueEl = cardEl.querySelector('.card-value-display');

                if(keepBtn) keepBtn.textContent = `Keep (${formatMoney(keepValue)})`;
                if(sellBtn) sellBtn.textContent = `Sell (${formatMoney(sellValue)})`;
                if(valueEl) valueEl.textContent = formatMoney(baseValue);
            }
        });
    }

    function addEffectToList(text) {
        const effectEl = document.createElement('p');
        effectEl.className = 'bg-gray-700 p-1 rounded';
        effectEl.textContent = text;
        activeEffectsList.appendChild(effectEl);
    }

    function getCardValue(card) {
        return calculateCardValue(card, state.deck, state);
    }

    function calculateCardValue(card, deckContext, runState) {
        const effect = card.copiedEffect || card.effect;

        if (effect?.type === 'EPHEMERAL' && effect.payload.value) {
            const isCardInDeck = deckContext.some(deckCard => deckCard === card);
            if (isCardInDeck) {
                return effect.payload.value;
            }
        }
        
        if (effect) {
             if (effect.type === 'COPYCAT') {
                const cardsToMimic = deckContext.filter(c => c.baseRarity === effect.payload.rarity && c.id !== card.id);
                if (cardsToMimic.length > 0) {
                    return Math.max(...cardsToMimic.map(c => calculateCardValue(c, deckContext, runState)));
                }
            }
            if (effect.type === 'MIRROR_EFFECT') {
                const otherCards = deckContext.filter(c => c.id !== card.id && c.effect && c.effect.type !== 'MIRROR_EFFECT');
                if (otherCards.length > 0) {
                    const randomCardToCopy = otherCards[card.id % otherCards.length];
                    const tempCard = { ...card, effect: randomCardToCopy.effect };
                    return calculateCardValue(tempCard, deckContext, runState);
                }
            }
        }

        let coreValue = card.baseRarity.value + runState.flatCardValueBonus;

        if (effect?.type === 'RISK_REWARD' && effect.payload.value_multiplier) {
            coreValue *= effect.payload.value_multiplier;
        }

        const finishMultiplier = card.finishes.reduce((acc, f) => acc * f.multiplier, 1);
        coreValue *= finishMultiplier;
        coreValue *= getConditionMultiplier(card.condition);
        let finalValue = coreValue;
        
        if (effect) {
             if (effect.type === 'TYPE_SYNERGY') {
                const count = deckContext.filter(c => (Array.isArray(c.type) && c.type.includes(effect.payload.type)) || c.type === effect.payload.type || c.type === TYPES.WILD).length;
                finalValue += count * effect.payload.amount;
             }
             if (effect.type === 'MULTI_TYPE_SYNERGY') {
                const count = deckContext.filter(c => effect.payload.types.some(t => (Array.isArray(c.type) && c.type.includes(t)) || c.type === t || c.type === TYPES.WILD)).length;
                finalValue += count * effect.payload.amount;
             }
             if (effect.type === 'RARITY_SYNERGY') {
                finalValue += deckContext.filter(c => c.baseRarity === effect.payload.rarity).length * effect.payload.amount;
             }
             if (effect.type === 'CONDITION_SYNERGY') {
                finalValue += deckContext.filter(c => c.condition >= effect.payload.threshold).length * effect.payload.amount;
             }
             if (effect.type === 'DECK_SIZE_SYNERGY') {
                finalValue += Math.floor(deckContext.length / effect.payload.per) * effect.payload.amount;
             }
             if (effect.type === 'BURN_SYNERGY') {
                finalValue += runState.cardsBurnedThisRun * effect.payload.amount;
             }
             if (effect.type === 'VALUE_OVER_TIME') {
                const packsOpenedSinceKept = (runState.packsPurchased['total'] || 0) - (card.keptAtPackCount !== undefined ? card.keptAtPackCount : (runState.packsPurchased['total'] || 0));
                finalValue += packsOpenedSinceKept * effect.payload.amount;
             }
             if (effect.type === 'NAME_SYNERGY') {
                const count = deckContext.filter(c => c.name.toLowerCase().includes(effect.payload.keyword)).length;
                finalValue += count * effect.payload.amount;
             }
        }

        if (card.type) {
            const cardTypes = Array.isArray(card.type) ? card.type : [card.type];
            cardTypes.forEach(type => {
                if (runState.valueModifiers[type.name]) {
                    finalValue += runState.valueModifiers[type.name];
                }
            });
        }
        
        let typeMultiplier = 1;
        const multiplierCards = deckContext.filter(c => (c.copiedEffect || c.effect)?.type === 'TYPE_VALUE_MULTIPLIER');
        if (multiplierCards.length > 0) {
            const cardTypes = Array.isArray(card.type) ? card.type : [card.type];
            for (const type of cardTypes) {
                const matchingCard = multiplierCards.find(mc => (mc.copiedEffect || mc.effect).payload.type === type);
                if (matchingCard) {
                    // Use the actual multiplier from the effect, not hardcoded 2
                    typeMultiplier = Math.max(typeMultiplier, (matchingCard.copiedEffect || matchingCard.effect).payload.multiplier);
                }
            }
        }
        if (typeMultiplier > 1) {
            finalValue *= typeMultiplier;
        }

        const finishMultiplierCard = deckContext.find(c => (c.copiedEffect || c.effect)?.type === 'FINISH_VALUE_MULTIPLIER');
        if (!card.finishes.some(f => f === FINISHES.STANDARD) && finishMultiplierCard) {
            finalValue *= (finishMultiplierCard.copiedEffect || finishMultiplierCard.effect).payload.multiplier;
        }
        
        const avgConditionCard = deckContext.find(c => (c.copiedEffect || c.effect)?.type === 'AVERAGE_CONDITION_SYNERGY');
        if (avgConditionCard && deckContext.length > 0) {
            const totalCondition = deckContext.reduce((sum, c) => sum + c.condition, 0);
            const avgCondition = totalCondition / deckContext.length;
            if (avgCondition >= (avgConditionCard.copiedEffect || avgConditionCard.effect).payload.threshold) {
                finalValue *= (avgConditionCard.copiedEffect || avgConditionCard.effect).payload.multiplier;
            }
        }

        // Handle negative wild synergy from RISK_REWARD cards
        const negativeWildCards = deckContext.filter(c => {
            const eff = c.copiedEffect || c.effect;
            return eff?.type === 'RISK_REWARD' && eff.payload.negative_wild_synergy && c.id !== card.id;
        });
        if (negativeWildCards.length > 0 && (card.type === TYPES.WILD || (Array.isArray(card.type) && card.type.includes(TYPES.WILD)))) {
            negativeWildCards.forEach(negCard => {
                const eff = negCard.copiedEffect || negCard.effect;
                finalValue += eff.payload.negative_wild_synergy; // This is negative, so it reduces value
            });
        }

        return finalValue < 0 ? 0 : finalValue;
    }


    function getPersistentCardValue(card) {
        if (!card || !card.baseRarity || !card.finishes) return 0;
        let coreValue = card.baseRarity.value;
        const finishMultiplier = card.finishes.reduce((acc, f) => acc * f.multiplier, 1);
        coreValue *= finishMultiplier;
        coreValue *= getConditionMultiplier(card.condition);
        return coreValue;
    }
    
    function getConditionMultiplier(condition) {
        if (!condition) return 1;
        if (condition >= 10.1) return 3.0;
        if (condition === 10.0) return 2.0;
        if (condition >= 9.0) return 1.5 + (condition - 9.0) * 0.5;
        if (condition >= 7.0) return 1.0 + (condition - 7.0) * 0.25;
        if (condition >= 5.0) return 0.6 + (condition - 5.0) * 0.2;
        return 0.1 + (condition - 1.0) * (0.5 / 4.0);
    }

    // --- UI & RENDERING ---
    function getSortedDeck() {
        const deckWithIndices = state.deck.map((card, index) => ({ card, originalIndex: index }));

        switch (deckViewState.sortBy) {
            case 'newest':
                return deckWithIndices.reverse(); // Newest first (reverse order)
            case 'oldest':
                return deckWithIndices; // Oldest first (original order)
            case 'value-high':
                return deckWithIndices.sort((a, b) => getCardValue(b.card) - getCardValue(a.card));
            case 'value-low':
                return deckWithIndices.sort((a, b) => getCardValue(a.card) - getCardValue(b.card));
            case 'rarity':
                return deckWithIndices.sort((a, b) => b.card.baseRarity.value - a.card.baseRarity.value);
            case 'name':
                return deckWithIndices.sort((a, b) => a.card.name.localeCompare(b.card.name));
            default:
                return deckWithIndices;
        }
    }

    function createMiniCard(card, originalIndex) {
        const miniCard = document.createElement('div');

        // Check if card should be highlighted
        let highlightClass = '';
        if(state.highlightedTypes.length > 0) {
            const cardTypes = Array.isArray(card.type) ? card.type.map(t => t.name) : [card.type.name];
            if(card.type === TYPES.WILD || cardTypes.some(type => state.highlightedTypes.includes(type))) {
                highlightClass = 'highlight';
            }
        }

        miniCard.className = `
            relative bg-gray-800 rounded-lg overflow-hidden transition-all duration-200
            hover:scale-105 hover:shadow-lg hover:shadow-blue-500/20
            border-2 ${card.baseRarity.colorClass} ${highlightClass}
            aspect-[2/3] w-full
        `;

        const sellValue = getSellValue(card);
        const cardValue = getCardValue(card);

        // Get finish classes
        const finishClasses = card.finishes.map(f => f.className).filter(c => c).join(' ');

        miniCard.innerHTML = `
            <div class="absolute inset-0 ${finishClasses}" style="background-image: url('${card.img}'); background-size: cover; background-position: center;"></div>
            <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent"></div>

            <!-- Condition indicator (top left) -->
            <div class="absolute top-1 left-1 bg-black/60 rounded px-1 text-xs text-white">
                ${card.condition.toFixed(1)}
            </div>

            <!-- Type icon (top right) -->
            <div class="absolute top-1 right-1 text-lg">
                ${Array.isArray(card.type) ? card.type.map(t => t.icon).join('') : card.type.icon}
            </div>

            <!-- Card name and actions -->
            <div class="absolute bottom-0 left-0 right-0 p-2">
                <div class="text-xs font-bold text-white truncate mb-1">${card.name}</div>
                <div class="text-xs text-green-400 font-semibold mb-1">${formatMoney(cardValue)}</div>
                <div class="grid grid-cols-3 gap-1">
                    <button class="mini-burn-btn bg-red-600/80 hover:bg-red-600 px-1 py-1 rounded text-xs">🔥</button>
                    <button class="mini-sell-btn bg-green-600/80 hover:bg-green-600 px-1 py-1 rounded text-xs col-span-2">${formatMoney(sellValue)}</button>
                </div>
            </div>
        `;

        // Add event listeners after creating the HTML
        const burnBtn = miniCard.querySelector('.mini-burn-btn');
        const sellBtn = miniCard.querySelector('.mini-sell-btn');

        burnBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            burnCard(originalIndex);
        });

        sellBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sellCardFromDeck(originalIndex);
        });

        return miniCard;
    }

    function updateDeckPagination(totalPages) {
        if (totalPages <= 1) {
            deckPagination.classList.add('hidden');
            return;
        }

        deckPagination.classList.remove('hidden');
        deckPageInfo.textContent = `Page ${deckViewState.currentPage} of ${totalPages}`;

        deckPrevPage.disabled = deckViewState.currentPage <= 1;
        deckNextPage.disabled = deckViewState.currentPage >= totalPages;
    }

    function updateDeckboxBackground() {
        const deckSection = document.getElementById('deck-section');
        const equippedDeckbox = state.equippedMerchandise['Deck Box'];

        // Remove all deckbox theme classes
        deckSection.classList.remove('deckbox-cardboard', 'deckbox-plastic', 'deckbox-reinforced', 'deckbox-vault');

        if (equippedDeckbox) {
            // Map deckbox IDs to CSS classes
            const deckboxThemes = {
                'db_c_cardboard': 'deckbox-cardboard',
                'db_u_plastic': 'deckbox-plastic',
                'db_r_reinforced': 'deckbox-reinforced',
                'db_ur_vault': 'deckbox-vault'
            };

            const themeClass = deckboxThemes[equippedDeckbox.id];
            if (themeClass) {
                deckSection.classList.add(themeClass);
                console.log(`Applied deckbox theme: ${themeClass} for ${equippedDeckbox.name}`);
            }
        }
    }

    function updateSleevesBackground() {
        const packOpeningSection = document.getElementById('pack-opening-section');
        const equippedSleeves = state.equippedMerchandise['Sleeves'];

        // Remove all sleeves theme classes
        packOpeningSection.classList.remove('sleeves-penny', 'sleeves-protective', 'sleeves-lucky', 'sleeves-holo', 'sleeves-gilded', 'sleeves-dragon', 'sleeves-starlight');

        if (equippedSleeves) {
            // Map sleeves IDs to CSS classes
            const sleevesThemes = {
                'sl_c_penny': 'sleeves-penny',
                'sl_u_protective': 'sleeves-protective',
                'sl_u_lucky': 'sleeves-lucky',
                'sl_r_holo': 'sleeves-holo',
                'sl_r_gilded': 'sleeves-gilded',
                'sl_ur_dragon': 'sleeves-dragon',
                'sl_sr_starlight': 'sleeves-starlight'
            };

            const themeClass = sleevesThemes[equippedSleeves.id];
            if (themeClass) {
                packOpeningSection.classList.add(themeClass);
                console.log(`Applied sleeves theme: ${themeClass} for ${equippedSleeves.name}`);
            }
        }
    }

    function updateBinderBackground() {
        const sidebar = document.querySelector('.lg\\:col-span-1');
        const equippedBinder = state.equippedMerchandise['Binder'];

        // Remove all binder theme classes
        sidebar.classList.remove('binder-folder', 'binder-collector', 'binder-trader', 'binder-pro', 'binder-master');

        if (equippedBinder) {
            // Map binder IDs to CSS classes
            const binderThemes = {
                'b_c_folder': 'binder-folder',
                'b_u_collector': 'binder-collector',
                'b_r_trader': 'binder-trader',
                'b_ur_pro': 'binder-pro',
                'b_sr_master': 'binder-master'
            };

            const themeClass = binderThemes[equippedBinder.id];
            if (themeClass) {
                sidebar.classList.add(themeClass);
                console.log(`Applied binder theme: ${themeClass} for ${equippedBinder.name}`);
            }
        }
    }

    function renderDeck() {
        // Update summary stats
        deckSummaryCount.textContent = state.deck.length;
        deckSummaryValue.textContent = formatMoney(state.deckValue);

        // Don't render if collapsed
        if (deckViewState.isCollapsed) {
            deckContent.style.display = 'none';
            return;
        } else {
            deckContent.style.display = 'block';
        }

        // Sort deck based on current sort option
        const sortedDeck = getSortedDeck();

        // Calculate pagination
        const totalPages = Math.ceil(sortedDeck.length / deckViewState.cardsPerPage);
        const startIndex = (deckViewState.currentPage - 1) * deckViewState.cardsPerPage;
        const endIndex = startIndex + deckViewState.cardsPerPage;
        const pageCards = sortedDeck.slice(startIndex, endIndex);

        // Update pagination UI
        updateDeckPagination(totalPages);

        // Clear and render cards
        deckGrid.innerHTML = '';

        if (state.deck.length === 0) {
            deckGrid.innerHTML = '<div class="col-span-full text-center text-gray-400 py-8">No cards in deck yet!</div>';
            return;
        }

        pageCards.forEach((cardData) => {
            const { card, originalIndex } = cardData;
            const deckCardContainer = document.createElement('div');
            deckCardContainer.className = 'tooltip-container relative group cursor-pointer';

            // Create mini card
            const miniCard = createMiniCard(card, originalIndex);
            deckCardContainer.appendChild(miniCard);

            // Create tooltip with full card
            const tooltipContent = createCardElement(card, 'collection');
            if(card.copiedEffect) {
                const copiedEffectDesc = document.createElement('p');
                copiedEffectDesc.className = "text-xs text-purple-400 mt-2 text-center italic p-1";
                copiedEffectDesc.textContent = `Copied: ${card.copiedDesc}`;
                tooltipContent.querySelector('.card-effect-content .card-content').appendChild(copiedEffectDesc);
            }

            const tooltipWrapper = document.createElement('div');
            tooltipWrapper.className = 'tooltip';
            tooltipWrapper.appendChild(tooltipContent);
            deckCardContainer.appendChild(tooltipWrapper);

            deckGrid.appendChild(deckCardContainer);
        });
    }

    function burnCard(cardIndexToBurn, isFromEffect = false) {
        if (isFromEffect || state.burnsLeft > 0) {
            if (cardIndexToBurn > -1 && cardIndexToBurn < state.deck.length) {
                const cardToBurn = state.deck[cardIndexToBurn];
                state.deck.splice(cardIndexToBurn, 1);
                
                state.cardsBurnedThisRun++;

                if (!isFromEffect) {
                    state.manualBurnsUsedThisRun++;
                }

                metaState.collectionBook = metaState.collectionBook.filter(c => c.id !== cardToBurn.id);
                if (state.replacedCardsHistory[cardToBurn.id] && state.replacedCardsHistory[cardToBurn.id].length > 0) {
                    const previousVersion = state.replacedCardsHistory[cardToBurn.id].pop();
                    metaState.collectionBook.push(previousVersion);
                }
                saveMetaState();

                recalculateState();
            }
        }
    }

    function sellCardFromDeck(cardIndexToSell) {
        if (state.sellsLeft > 0) {
            if (cardIndexToSell > -1 && cardIndexToSell < state.deck.length) {
                const cardToSell = state.deck[cardIndexToSell];

                state.money += getSellValue(cardToSell);
                state.deck.splice(cardIndexToSell, 1);
                state.sellsUsedThisRun++;
                
                if(!state.deck.some(c => (c.copiedEffect || c.effect)?.type === 'PERSISTENT_SELLS')) {
                    metaState.collectionBook = metaState.collectionBook.filter(c => c.id !== cardToSell.id);
                    if (state.replacedCardsHistory[cardToSell.id] && state.replacedCardsHistory[cardToSell.id].length > 0) {
                        const previousVersion = state.replacedCardsHistory[cardToSell.id].pop();
                        metaState.collectionBook.push(previousVersion);
                    }
                }
                saveMetaState();
                recalculateState();
            }
        }
    }

    function updateUI() {
        moneyDisplay.textContent = formatMoney(state.money);
        deckValueDisplay.textContent = formatMoney(state.deckValue);
        deckCount.textContent = `${state.deck.length} / ${state.maxDeckSize}`;
        burnCount.textContent = state.burnsLeft;
        sellCount.textContent = state.sellsLeft;
        
        document.querySelectorAll('.shop-pack-btn').forEach(btn => {
            const packKey = btn.dataset.pack;
            const numPurchased = state.packsPurchased[packKey] || 0;
            const costIncrease = (numPurchased * (numPurchased + 1) / 2) * 0.01;
            const cost = (PACK_DEFINITIONS[packKey].cost + costIncrease) * (1 - state.shopDiscount);
            const costEl = btn.querySelector('.pack-price');
            if(costEl) costEl.textContent = formatMoney(cost);
            btn.disabled = state.money < cost;
        });
        checkEndConditions();
    }

    function createCardButtons(card, cardEl) {
        const keepValue = calculateCardValue(card, [...state.deck, card], state);
        const sellValue = getSellValue(card);

        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'card-buttons';

        const keepBtn = document.createElement('button');
        keepBtn.textContent = `Keep (${formatMoney(keepValue)})`;
        keepBtn.className = 'keep-btn bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1.5 px-2 rounded transition-colors';
        keepBtn.onclick = () => keepCard(card, cardEl, buttonContainer);

        const sellBtn = document.createElement('button');
        sellBtn.textContent = `Sell (${formatMoney(sellValue)})`;
        sellBtn.className = 'sell-btn bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1.5 px-2 rounded transition-colors';
        sellBtn.onclick = () => sellCard(card, cardEl, buttonContainer);

        buttonContainer.appendChild(keepBtn);
        buttonContainer.appendChild(sellBtn);

        return buttonContainer;
    }

    function displayOpenedCards(cards) {
        packOpeningGrid.innerHTML = '';
        cards.forEach(card => {
            const cardEl = createCardElement(card, 'open');
            const buttonContainer = createCardButtons(card, cardEl);

            const cardWithButtons = document.createElement('div');
            cardWithButtons.className = 'card-with-buttons';
            cardWithButtons.appendChild(cardEl);
            cardWithButtons.appendChild(buttonContainer);

            packOpeningGrid.appendChild(cardWithButtons);
        });
        sellAllBtn.classList.remove('hidden');
    }

    function addCardIndicator(cardEl, card) {
        cardEl.querySelector('.card-indicator')?.remove();

        const existingCard = metaState.collectionBook.find(c => c.id === card.id);
        
        if (!existingCard && metaState.showNewCardIndicator) {
            const indicator = document.createElement('div');
            indicator.className = 'card-indicator indicator-new';
            indicator.textContent = '!';
            cardEl.appendChild(indicator);
        } else if (existingCard && getPersistentCardValue(card) > getPersistentCardValue(existingCard) && metaState.showUpgradeCardIndicator) {
            const indicator = document.createElement('div');
            indicator.className = 'card-indicator indicator-upgrade';
            indicator.textContent = '$';
            cardEl.appendChild(indicator);
        }
    }
    
    function updateOpenCardIndicators() {
        packOpeningGrid.querySelectorAll('.card').forEach(cardEl => {
            if (cardEl.cardData) {
                // Update card indicators (new/upgrade)
                addCardIndicator(cardEl, cardEl.cardData);

                // Update condition indicator
                const existingCondition = cardEl.querySelector('.card-condition');
                if (existingCondition) {
                    existingCondition.remove();
                }

                if (cardEl.cardData.condition && metaState.showConditionIndicator) {
                    let conditionHTML = '';
                    if (cardEl.cardData.condition >= 10.1) {
                        conditionHTML = `<div class="card-condition gem-mint">GEM MINT</div>`;
                    } else {
                        conditionHTML = `<div class="card-condition">${cardEl.cardData.condition.toFixed(1)}</div>`;
                    }
                    cardEl.insertAdjacentHTML('beforeend', conditionHTML);
                }
            }
        });
    }

    function createCardElement(card, context = 'collection') {
        const cardEl = document.createElement('div');
        cardEl.cardData = card;
        
        const finishNames = card.finishes.filter(f => f !== FINISHES.STANDARD && !f.secret).map(f => f.name).join(' ');
        const displayRarity = `${finishNames} ${card.baseRarity.name}`.trim();
        const finishClasses = card.finishes.map(f => f.className).join(' ');

        let highlightClass = '';
        if((context === 'open' || context === 'deck') && state.highlightedTypes.length > 0) {
            const cardTypes = Array.isArray(card.type) ? card.type.map(t => t.name) : [card.type.name];
            if(card.type === TYPES.WILD || cardTypes.some(type => state.highlightedTypes.includes(type))) {
                highlightClass = 'highlight';
                console.log(`Highlighting ${card.name} (${cardTypes.join(',')}) in context ${context}`);
            }
        }

        cardEl.className = `card border-4 ${card.baseRarity.colorClass} ${finishClasses} ${highlightClass} rounded-lg p-3 flex flex-col shadow-lg`;

        // Add card artwork as background for all cards
        if (card.img) {
            if (card.finishes.some(f => f === FINISHES.FULL_ART)) {
                // Full art cards use the image as full background
                cardEl.style.backgroundImage = `url('${card.img}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center';
            } else {
                // Regular cards use the image as background with overlay for text readability
                cardEl.style.backgroundImage = `url('${card.img}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center';
            }
        }

        let effectHTML = card.desc ? card.desc : 'No Effect';
        
        let conditionHTML = '';
        if (card.condition && metaState.showConditionIndicator) {
            if (card.condition >= 10.1) {
                conditionHTML = `<div class="card-condition gem-mint">GEM MINT</div>`;
            } else {
                conditionHTML = `<div class="card-condition">${card.condition.toFixed(1)}</div>`;
            }
        }

        let pullRateHTML = '';
        if (context === 'book') {
            const pullRateKey = card.id;
            const currentGen = metaState.collectionBookView.activeGen;
            if (PULL_RATE_CACHE[currentGen] && PULL_RATE_CACHE[currentGen][pullRateKey]) {
                const rate = PULL_RATE_CACHE[currentGen][pullRateKey];
                pullRateHTML = `<div class="card-pull-rate" title="Approx. pull rate for this base card from a standard pack">${formatPercent(rate)}</div>`;
            }
        }

        // Determine name length class for auto-sizing
        let nameClass = 'card-name';
        if (card.name.length > 20) {
            nameClass += ' very-long-name';
        } else if (card.name.length > 15) {
            nameClass += ' long-name';
        }

        // Determine rarity info length class for auto-sizing
        let rarityClass = 'card-rarity-info';
        if (displayRarity.length > 20) {
            rarityClass += ' long-info';
        }

        // Handle type icons positioning
        const isDualType = Array.isArray(card.type);
        let typeIconsHTML;
        if (isDualType) {
            typeIconsHTML = `<div class="card-type-icons dual-type">
                <div class="card-type-icon">${card.type[0].icon}</div>
                <div class="card-type-icon">${card.type[1].icon}</div>
            </div>`;
        } else {
            typeIconsHTML = `<div class="card-type-icons">
                <div class="card-type-icon">${card.type.icon}</div>
            </div>`;
        }

        cardEl.innerHTML = `
            ${conditionHTML}
            ${pullRateHTML}
            <div class="card-content-wrapper">
                ${typeIconsHTML}
                <div class="card-name-area">
                    <div class="${nameClass}">${card.name}</div>
                    <div class="${rarityClass}">${displayRarity}</div>
                </div>
                <div class="card-effect-content">
                    <div class="card-content">${effectHTML}</div>
                </div>
            </div>
            <div class="card-value-display"></div>
        `;

        if (context === 'open') {
            addCardIndicator(cardEl, card);
            // Show base collection value (rarity + condition + finish only)
            const baseValue = getPersistentCardValue(card);
            cardEl.querySelector('.card-value-display').textContent = formatMoney(baseValue);
        } else {
            const value = getPersistentCardValue(card);
            cardEl.querySelector('.card-value-display').textContent = formatMoney(value);
        }
        // Apply misprint errors if card has misprint finish
        if (card.finishes.includes(FINISHES.MISPRINT)) {
            applyMisprintErrors(cardEl, card);
        }

        return cardEl;
    }

    function applyMisprintErrors(cardEl, card) {
        // Use stored misprint errors if available, otherwise generate new ones (for backward compatibility)
        let misprintErrors = card.misprintErrors;
        if (!misprintErrors) {
            // Generate errors for cards that don't have them stored (backward compatibility)
            misprintErrors = generateMisprintErrors(card);
            // Store them on the card for consistency
            card.misprintErrors = misprintErrors;
        }

        misprintErrors.types.forEach(errorType => {
            switch (errorType) {
                case 'name_typo':
                    applyStoredNameTypo(cardEl, card, misprintErrors.data.corruptedName);
                    break;
                case 'missing_text':
                    applyMissingText(cardEl);
                    break;
                case 'image_offset':
                    cardEl.classList.add('misprint-image-offset');
                    break;
                case 'image_rotated':
                    applyRotatedBackground(cardEl);
                    break;
                case 'image_inverted':
                    cardEl.classList.add('misprint-image-inverted');
                    break;
                case 'image_color_error':
                    cardEl.classList.add('misprint-image-error');
                    break;
                case 'effect_typo':
                    applyStoredEffectTypo(cardEl, card, misprintErrors.data.corruptedEffect);
                    break;
            }
        });
    }

    function applyStoredNameTypo(cardEl, card, corruptedName) {
        const nameEl = cardEl.querySelector('.card-name');
        if (nameEl && corruptedName) {
            nameEl.classList.add('misprint-name-error');
            nameEl.setAttribute('data-corrected', card.name);
            nameEl.textContent = corruptedName;
        }
    }

    function applyNameTypo(cardEl, card) {
        const nameEl = cardEl.querySelector('.card-name');
        if (nameEl) {
            const originalName = card.name;
            const typoName = createTypo(originalName);
            nameEl.classList.add('misprint-name-error');
            nameEl.setAttribute('data-corrected', originalName);
            nameEl.textContent = typoName;
        }
    }

    function applyMissingText(cardEl) {
        const effectEl = cardEl.querySelector('.card-content');
        if (effectEl) {
            effectEl.classList.add('misprint-text-missing');
            effectEl.innerHTML = '[TEXT MISSING]';
        }
    }

    function applyStoredEffectTypo(cardEl, card, corruptedEffect) {
        const effectEl = cardEl.querySelector('.card-content');
        if (effectEl && corruptedEffect) {
            effectEl.innerHTML = corruptedEffect;
        }
    }

    function applyEffectTypo(cardEl, card) {
        const effectEl = cardEl.querySelector('.card-content');
        if (effectEl && card.desc) {
            const typoEffect = createTypo(card.desc);
            effectEl.innerHTML = typoEffect;
        }
    }

    function applyRotatedBackground(cardEl) {
        // Get the current background image
        const currentBgImage = cardEl.style.backgroundImage;

        if (currentBgImage && currentBgImage !== 'none') {
            // Create a container for the rotated background
            const bgContainer = document.createElement('div');
            bgContainer.className = 'misprint-rotated-bg';
            bgContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: ${currentBgImage};
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                transform: rotate(180deg);
                z-index: -1;
                border-radius: inherit;
            `;

            // Remove background from the card element
            cardEl.style.backgroundImage = 'none';

            // Ensure card has relative positioning
            cardEl.style.position = 'relative';

            // Add the rotated background container
            cardEl.appendChild(bgContainer);
        }
    }

    function createTypo(text) {
        const typoTypes = [
            'letter_swap',
            'missing_letter',
            'extra_letter',
            'wrong_letter',
            'repeated_word'
        ];

        const typoType = typoTypes[Math.floor(Math.random() * typoTypes.length)];
        let result = text;

        switch (typoType) {
            case 'letter_swap':
                if (result.length > 3) {
                    const pos = Math.floor(Math.random() * (result.length - 2)) + 1;
                    const chars = result.split('');
                    [chars[pos], chars[pos + 1]] = [chars[pos + 1], chars[pos]];
                    result = chars.join('');
                }
                break;
            case 'missing_letter':
                if (result.length > 2) {
                    const pos = Math.floor(Math.random() * result.length);
                    result = result.slice(0, pos) + result.slice(pos + 1);
                }
                break;
            case 'extra_letter':
                const pos = Math.floor(Math.random() * result.length);
                const extraChar = 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
                result = result.slice(0, pos) + extraChar + result.slice(pos);
                break;
            case 'wrong_letter':
                if (result.length > 0) {
                    const pos = Math.floor(Math.random() * result.length);
                    const wrongChar = 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
                    result = result.slice(0, pos) + wrongChar + result.slice(pos + 1);
                }
                break;
            case 'repeated_word':
                const words = result.split(' ');
                if (words.length > 1) {
                    const wordIndex = Math.floor(Math.random() * words.length);
                    words.splice(wordIndex, 0, words[wordIndex]);
                    result = words.join(' ');
                }
                break;
        }

        return result;
    }

    // --- SHOP MODAL LOGIC ---
    function showFullShop() { fullShopModal.classList.remove('hidden'); fullShopModal.classList.add('flex'); renderFullShop(); }
    function closeFullShop() { fullShopModal.classList.add('hidden'); fullShopModal.classList.remove('flex'); }

    function renderFullShop() {
        packLicensingGrid.innerHTML = '';
        Object.keys(PACK_DEFINITIONS).forEach(packKey => {
            const packDef = PACK_DEFINITIONS[packKey];
            // Only show packs that have a license cost, aren't already licensed, AND have their generation unlocked
            if (!packDef.licenseCost || metaState.unlockedLicenses.includes(packKey)) return;

            // Extract generation from pack key (e.g., "gen1-elemental" -> "gen1")
            const generation = packKey.split('-')[0];
            if (!metaState.unlockedGens.includes(generation)) return;
            const canAfford = state.money >= packDef.licenseCost;
            const itemEl = document.createElement('div');
            itemEl.className = `shop-item bg-gray-700 p-3 rounded-lg flex flex-col items-center text-center ${!canAfford ? 'disabled' : 'cursor-pointer'}`;
            itemEl.innerHTML = `<p class="font-bold">${packDef.name}</p><p class="text-sm text-gray-400">License</p><p class="font-semibold text-yellow-400 mt-2">$${packDef.licenseCost.toLocaleString()}</p>`;
            if (canAfford) { itemEl.onclick = () => buyPackLicense(packKey); }
            packLicensingGrid.appendChild(itemEl);
        });

        merchandiseGridCommon.innerHTML = '';
        merchandiseGridSpecial.innerHTML = '';
        
        [...state.currentShopMerchandise.common, ...state.currentShopMerchandise.special].forEach(item => {
            const canAfford = state.money >= item.cost;
            const itemEl = document.createElement('div');
            const equippedItem = state.equippedMerchandise[item.type];
            let upgradeIndicator = '';
            if (equippedItem && item.cost > equippedItem.cost) {
                upgradeIndicator = '<span class="text-green-400 font-bold ml-2">⬆️</span>';
            }
            
            itemEl.className = `shop-item bg-gray-700 p-3 rounded-lg flex flex-col text-center border-2 ${item.rarity.colorClass} ${!canAfford ? 'disabled' : 'cursor-pointer'}`;
            itemEl.innerHTML = `<p class="font-bold text-sm flex-grow flex items-center justify-center">${item.name}${upgradeIndicator}</p><p class="text-xs text-gray-400 mb-2">${item.type}</p><p class="text-xs italic text-gray-300 mb-2 flex-grow">"${item.desc}"</p><p class="font-semibold text-green-400 mt-auto">$${item.cost.toLocaleString()}</p>`;
            if (canAfford) { itemEl.onclick = () => buyMerchandise(item); }
            
            if (item.rarity.value < BASE_RARITIES.RARE.value) {
                merchandiseGridCommon.appendChild(itemEl);
            } else {
                merchandiseGridSpecial.appendChild(itemEl);
            }
        });

        shopEquippedGearList.innerHTML = '';
        let hasGear = false;
        Object.values(state.equippedMerchandise).forEach(item => {
            if (item) {
                hasGear = true;
                const gearEl = document.createElement('div');
                gearEl.className = "bg-gray-800 p-2 rounded-lg text-left"
                gearEl.innerHTML = `<p class="font-bold text-sm">${item.name}</p><p class="text-xs text-gray-400">${item.rarity.name} ${item.type}</p><p class="text-xs italic mt-1">${item.desc}</p>`;
                shopEquippedGearList.appendChild(gearEl);
            }
        });
        if (!hasGear) {
            shopEquippedGearList.innerHTML = '<p class="text-gray-500">Nothing equipped.</p>';
        }
        
        restockMerchBtn.textContent = `Restock ($${state.restockCost.toLocaleString()})`;
        restockMerchBtn.disabled = state.money < state.restockCost;
    }

    function generateShopMerchandise() {
        const availableMerch = MERCHANDISE_POOL.filter(item => state.equippedMerchandise[item.type]?.id !== item.id);

        const commonPool = availableMerch.filter(item => item.rarity.value < BASE_RARITIES.RARE.value);
        const specialPool = availableMerch.filter(item => item.rarity.value >= BASE_RARITIES.RARE.value);

        state.currentShopMerchandise.common = [];
        state.currentShopMerchandise.special = [];

        for (let i = 0; i < 4; i++) {
            if (commonPool.length === 0) break;
            const randIndex = Math.floor(Math.random() * commonPool.length);
            state.currentShopMerchandise.common.push(commonPool.splice(randIndex, 1)[0]);
        }
        
        for (let i = 0; i < 4; i++) {
            if (specialPool.length === 0) break;
            const randIndex = Math.floor(Math.random() * specialPool.length);
            state.currentShopMerchandise.special.push(specialPool.splice(randIndex, 1)[0]);
        }
    }
    
    function restockMerchandise() {
        if (state.money >= state.restockCost) {
            state.money -= state.restockCost;
            state.restockCost = Math.round(state.restockCost * 1.5);
            generateShopMerchandise(); renderFullShop(); updateUI();
        }
    }

    function buyMerchandise(item) {
        if (state.money >= item.cost) {
            state.money -= item.cost;
            state.equippedMerchandise[item.type] = item;
            generateShopMerchandise();
            recalculateState();
            renderShop(); // Re-render pack buttons to show/hide condition indicators
            renderFullShop();
        }
    }

    function buyPackLicense(packKey) {
        const packDef = PACK_DEFINITIONS[packKey];
        if (state.money >= packDef.licenseCost) {
            state.money -= packDef.licenseCost;
            metaState.unlockedLicenses.push(packKey);
            saveMetaState(); renderFullShop(); renderShop(); updateUI();
        }
    }

    // --- COLLECTION BOOK LOGIC ---
    function showCollectionBook() {
        collectionBookModal.classList.remove('hidden');
        collectionBookModal.classList.add('flex');

        // Update button states
        viewLastRunBtn.disabled = !metaState.lastRunData;
        if (!metaState.lastRunData) {
            viewLastRunBtn.classList.add('opacity-50', 'cursor-not-allowed');
            viewLastRunBtn.title = 'No previous run data available';
        } else {
            viewLastRunBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            viewLastRunBtn.title = `View results from run on ${new Date(metaState.lastRunData.timestamp).toLocaleDateString()}`;
        }

        renderCollectionBook(metaState.collectionBookView.activeGen);
    }

    function closeCollectionBook() {
        collectionBookModal.classList.add('hidden');
        collectionBookModal.classList.remove('flex');
    }

    function showBigBook() {
        bigBookModal.classList.remove('hidden');
        bigBookModal.classList.add('flex');
        renderBigBook();
    }

    function closeBigBook() {
        bigBookModal.classList.add('hidden');
        bigBookModal.classList.remove('flex');
    }

    function renderBigBook() {
        const activeGen = metaState.bigBookView.activeGen;

        // Create generation tabs
        bigBookTabs.innerHTML = '';
        Object.keys(CARD_GENERATIONS).forEach(genKey => {
            if(!metaState.unlockedGens.includes(genKey)) return;
            const tab = document.createElement('button');
            tab.textContent = genKey.toUpperCase();
            tab.className = `collection-book-tab font-semibold py-2 px-4 border-b-4 transition-colors ${activeGen === genKey ? 'active' : 'border-transparent hover:border-gray-500'}`;
            tab.onclick = () => {
                metaState.bigBookView.activeGen = genKey;
                metaState.bigBookView.currentPage = 1;
                renderBigBook();
            };
            bigBookTabs.appendChild(tab);
        });

        // Filter cards by generation
        const cardsInGen = metaState.bigBook.filter(card => {
            const cardDef = CARD_GENERATIONS[activeGen].find(c => c.id === card.id);
            return cardDef !== undefined;
        });

        // Update stats
        const totalCards = metaState.bigBook.length;
        const totalValue = metaState.bigBook.reduce((sum, card) => sum + getPersistentCardValue(card), 0);
        const cardsInThisGen = cardsInGen.length;

        // Count unique card IDs for better stats
        const uniqueCardIds = new Set(metaState.bigBook.map(card => card.id));
        const uniqueCardsInGen = new Set(cardsInGen.map(card => card.id));

        bigBookStats.innerHTML = `
            <div>Total Entries: <span class="text-yellow-400 font-bold">${totalCards}</span></div>
            <div>Unique Cards: <span class="text-purple-400 font-bold">${uniqueCardIds.size}</span></div>
            <div>This Gen: <span class="text-blue-400 font-bold">${cardsInThisGen}</span> (${uniqueCardsInGen.size} unique)</div>
            <div>Total Value: <span class="text-green-400 font-bold">${formatMoney(totalValue)}</span></div>
        `;

        // Dynamic pagination - calculate pages needed
        const { currentPage, cardsPerPage } = metaState.bigBookView;
        const totalPages = Math.max(1, Math.ceil(cardsInGen.length / cardsPerPage));

        // Ensure current page is valid
        if (currentPage > totalPages && totalPages > 0) {
            metaState.bigBookView.currentPage = totalPages;
        }

        const validCurrentPage = Math.max(1, Math.min(metaState.bigBookView.currentPage, totalPages));
        const startIndex = (validCurrentPage - 1) * cardsPerPage;
        const endIndex = startIndex + cardsPerPage;
        const pagedCards = cardsInGen.slice(startIndex, endIndex);

        // Render cards
        bigBookGrid.innerHTML = '';

        if (pagedCards.length === 0) {
            // Show empty state
            const emptyEl = document.createElement('div');
            emptyEl.className = 'col-span-5 text-center text-gray-400 text-xl py-8';
            emptyEl.innerHTML = `
                <div class="text-4xl mb-4">📚</div>
                <div>No cards collected yet for ${activeGen.toUpperCase()}</div>
                <div class="text-sm mt-2">Start opening packs to fill your Big Book!</div>
            `;
            bigBookGrid.appendChild(emptyEl);
        } else {
            // Render actual cards
            pagedCards.forEach(card => {
                const cardEl = createCardElement(card, 'book');
                cardEl.classList.add('cursor-pointer');
                cardEl.onclick = () => showCardDetailModal(card);

                // Add collection timestamp and finish info
                const infoEl = document.createElement('div');
                infoEl.className = 'absolute top-1 left-1 bg-black bg-opacity-70 text-white text-xs px-1 rounded z-10';
                infoEl.innerHTML = `
                    <div>${new Date(card.collectedAt).toLocaleDateString()}</div>
                    <div class="text-yellow-300">${card.finishes[0].name}</div>
                `;
                cardEl.style.position = 'relative';
                cardEl.appendChild(infoEl);

                bigBookGrid.appendChild(cardEl);
            });
        }

        // Update pagination controls
        bigBookPageInfo.textContent = cardsInGen.length === 0 ? 'No cards' : `Page ${validCurrentPage} of ${totalPages}`;
        bigBookPrevBtn.disabled = validCurrentPage <= 1 || cardsInGen.length === 0;
        bigBookNextBtn.disabled = validCurrentPage >= totalPages || cardsInGen.length === 0;
    }

    function renderCollectionBook() {
        const activeGen = metaState.collectionBookView.activeGen;
        collectionBookTabs.innerHTML = '';
        Object.keys(CARD_GENERATIONS).forEach(genKey => {
            if(!metaState.unlockedGens.includes(genKey)) return;
            const tab = document.createElement('button');
            tab.textContent = genKey.toUpperCase();
            tab.className = `collection-book-tab font-semibold py-2 px-4 border-b-4 transition-colors ${activeGen === genKey ? 'active' : 'border-transparent hover:border-gray-500'}`;
            tab.onclick = () => {
                metaState.collectionBookView.activeGen = genKey;
                metaState.collectionBookView.currentPage = 1;
                renderCollectionBook();
            };
            collectionBookTabs.appendChild(tab);
        });
        
        const allCardsInGen = CARD_GENERATIONS[activeGen].sort((a,b) => a.id - b.id);
        
        const { currentPage, cardsPerPage } = metaState.collectionBookView;
        const totalPages = Math.ceil(allCardsInGen.length / cardsPerPage);
        
        const pagedIndices = Array.from({ length: cardsPerPage }, (_, i) => ((currentPage - 1) * cardsPerPage) + i);

        collectionBookGrid.innerHTML = '';

        // Always render exactly 10 slots (2 rows of 5)
        for (let i = 0; i < cardsPerPage; i++) {
            const cardIndex = pagedIndices[i];
            const baseCard = allCardsInGen[cardIndex];

            if (baseCard) {
                const collectedVersion = metaState.collectionBook.find(c => c.id === baseCard.id);
                if (collectedVersion) {
                    const cardEl = createCardElement(collectedVersion, 'book');
                    cardEl.classList.add('cursor-pointer');
                    cardEl.onclick = () => showCardDetailModal(collectedVersion);
                    collectionBookGrid.appendChild(cardEl);
                } else {
                    const placeholderEl = document.createElement('div');
                    placeholderEl.className = 'card bg-none border-4 border-dashed border-gray-600 rounded-lg p-3 flex flex-col items-center justify-center text-gray-500 hover:transform-none hover:shadow-none';
                    placeholderEl.innerHTML = `<p class="text-4xl font-bold">?</p><p class="text-xs mt-2">${baseCard.name}</p>`;
                    collectionBookGrid.appendChild(placeholderEl);
                }
            } else {
                // Empty slot - create invisible spacer to maintain grid layout
                const spacerEl = document.createElement('div');
                spacerEl.className = 'card invisible';
                collectionBookGrid.appendChild(spacerEl);
            }
        }

        collectionPageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        collectionPrevBtn.disabled = currentPage === 1;
        collectionNextBtn.disabled = currentPage === totalPages;
    }
    
    // --- PULL RATE SIMULATION ---
    async function runPackSimulation(genKey, silent = true) {
        console.log(`Running pack opening simulation for ${genKey}...`);
        const SIMULATION_PACKS = 20000;
        let totalCards = 0;
        const simState = { 
            luckBonus: 0, 
            conditionModifier: 0, 
            flatCardValueBonus: 0, 
            packSizeModifier: 0, 
            minimumCondition: 0,
            equippedMerchandise: {} 
        };

        const pullCounts = {};

        for (let i = 0; i < SIMULATION_PACKS; i++) {
            const pack = generatePack(genKey, simState);
            totalCards += pack.length;
            pack.forEach(card => {
                const key = card.id;
                if(!pullCounts[key]) pullCounts[key] = 0;
                pullCounts[key]++;
            });
        }
        
        PULL_RATE_CACHE[genKey] = {};
        for(const key in pullCounts) {
            PULL_RATE_CACHE[genKey][key] = pullCounts[key] / totalCards;
        }

        if (!silent) {
            renderCollectionBook();
        }
        console.log(`Pack simulation for ${genKey} complete.`);
    }

    // --- PACK ODDS MODAL ---
    function showPackOddsModal(packKey) {
        const packDef = PACK_DEFINITIONS[packKey];
        packOddsTitle.textContent = `${packDef.name} Odds`;
        
        let packLuck = state.luckBonus;
        if (packKey.includes('-rare')) {
            packLuck += 1.0;
        }
        const packLuckBonusPercent = (packLuck * 100).toFixed(0);
        const baseLuckBonusPercent = (state.luckBonus * 100).toFixed(0);
        
        const odds = {
            Common:     { Holo: 0.001, Prismatic: 0.0001, FullArt: 0.00001 },
            Uncommon:   { Holo: 0.01,  Prismatic: 0.001,  FullArt: 0.0001 },
            Rare:       { Holo: 0.1,   Prismatic: 0.01,   FullArt: 0.001 },
            'Ultra Rare': { Holo: 0.5,   Prismatic: 0.1,    FullArt: 0.01 },
            'Secret Rare':{ Holo: 1,     Prismatic: 0.1,    FullArt: 0.01 },
        };

        let finishTableHTML = Object.keys(odds).map(rarity => `
            <div>${rarity}</div>
            <div class="text-center">${formatPercent(odds[rarity].Holo * (rarity === 'Secret Rare' ? 1 : (1 + packLuck)))}</div>
            <div class="text-center">${formatPercent(odds[rarity].Prismatic * (1 + packLuck))}</div>
            <div class="text-center">${formatPercent(odds[rarity].FullArt * (1 + packLuck))}</div>
        `).join('');

        let rarityOddsHTML;
        if (packKey.includes('-rare')) {
            rarityOddsHTML = `
                <p><span class="font-semibold text-gray-400">Cards 1-3:</span> 50% Common, 50% Uncommon</p>
                <p><span class="font-semibold text-gray-400">Card 4:</span> ~10% Uncommon, ~80% Rare, ~9% Ultra-Rare, ~1% Secret Rare</p>
                <p><span class="font-semibold text-gray-400">Card 5:</span> ~45% Rare, ~50% Ultra-Rare, ~5% Secret Rare</p>
            `;
        } else {
            rarityOddsHTML = `
                <p><span class="font-semibold text-gray-400">Cards 1-3:</span> 100% Common</p>
                <p><span class="font-semibold text-gray-400">Card 4:</span> ~90% Uncommon, ~9% Rare, ~1% Ultra-Rare</p>
                <p><span class="font-semibold text-gray-400">Card 5:</span> ~90% Rare, ~9% Ultra-Rare, ~1% Secret Rare</p>
            `;
        }

        let contentHTML = `
            <div class="border-b border-gray-600 pb-2 mb-2">
                <p class="font-bold text-lg">Rarity Odds Per Slot:</p>
                ${rarityOddsHTML}
            </div>
        `;
        const actualPackSize = Math.min(10, packDef.cards + state.packSizeModifier);
        if (actualPackSize > 5) {
             contentHTML += `
                <div class="border-b border-gray-600 pb-2 mb-2">
                    <p class="font-bold text-lg">Additional Card Slots (Cards 6+):</p>
                    <p><span class="font-semibold text-gray-400">General Rarity:</span> 60% Common, 25% Uncommon, 10% Rare, 4% Ultra-Rare, 1% Secret Rare</p>
                    <p class="text-xs text-yellow-300 italic">*Maximum pack size is 10 cards</p>
                </div>
            `;
        }
         contentHTML += `
            <div class="border-b border-gray-600 pb-2 mb-2">
                <p class="font-bold text-lg">Calculated Special Finish Chances</p>
                <p class="text-sm text-yellow-300">Your current Luck Bonus: <span class="font-bold">+${baseLuckBonusPercent}%</span>.
                ${packKey.includes('-rare') ? 'This pack has an additional <span class="font-bold">+100%</span> bonus!' : ''}
                Total effective bonus: <span class="font-bold">+${packLuckBonusPercent}%</span></p>
                <div class="grid grid-cols-4 gap-x-2 text-xs mt-2 font-mono">
                    <div class="font-bold text-gray-400">Rarity</div>
                    <div class="font-bold text-gray-400 text-center">Holo</div>
                    <div class="font-bold text-gray-400 text-center">Prismatic</div>
                    <div class="font-bold text-gray-400 text-center">Full Art</div>
                    ${finishTableHTML}
                </div>
            </div>
            <div>
                <p class="text-xs text-gray-400 italic">*Special Finish chances are independent. A card can have multiple finishes.</p>
                ${packDef.rarityBias ? `<p class="text-xs text-yellow-300 italic">*This pack has an increased base chance to find rarer cards.</p>` : ''}
            </div>
        `;

        packOddsContent.innerHTML = contentHTML;
        packOddsModal.classList.remove('hidden');
        packOddsModal.classList.add('flex');
    }

    function closePackOddsModal() {
        packOddsModal.classList.add('hidden');
        packOddsModal.classList.remove('flex');
    }

    function checkForNewUnlocks() {
        const collectionBookValue = metaState.collectionBook.reduce((sum, card) => sum + getPersistentCardValue(card), 0);
        const oldUnlockedGens = [...metaState.unlockedGens];
        let unlockedSomething = false;

        for (const gen in UNLOCK_MILESTONES) {
            if (!metaState.unlockedGens.includes(gen) && collectionBookValue >= UNLOCK_MILESTONES[gen]) {
                metaState.unlockedGens.push(gen);
                unlockedSomething = true;
            }
        }

        if (unlockedSomething) {
            const newlyUnlocked = metaState.unlockedGens.filter(g => !oldUnlockedGens.includes(g));
            const unlockText = `🎉 You've unlocked ${newlyUnlocked.join(', ').toUpperCase()} packs!`;

            // Save the unlock immediately
            saveMetaState();

            // Show notification
            showNotification(unlockText);

            // Update shop displays if they're open
            if (!enterShopBtn.classList.contains('hidden')) {
                renderShop();
            }
            if (!fullShopModal.classList.contains('hidden')) {
                renderFullShop();
            }

            console.log('New generations unlocked:', newlyUnlocked);
            return newlyUnlocked;
        }

        return [];
    }

    function updateUnlockProgressUI() {
        const collectionBookValue = metaState.collectionBook.reduce((sum, card) => sum + getPersistentCardValue(card), 0);
        let nextUnlockGen = null;
        let nextUnlockGoal = Infinity;

        for (const gen in UNLOCK_MILESTONES) {
            if (!metaState.unlockedGens.includes(gen)) {
                nextUnlockGoal = UNLOCK_MILESTONES[gen];
                nextUnlockGen = gen;
                break;
            }
        }

        if (nextUnlockGen) {
            unlockLabel.textContent = `Unlock ${nextUnlockGen.toUpperCase()}`;
            const progress = Math.min(collectionBookValue / nextUnlockGoal, 1);
            unlockProgressBar.style.width = `${progress * 100}%`;
            unlockProgressText.textContent = `${formatMoney(collectionBookValue)} / ${formatMoney(nextUnlockGoal)}`;
        } else {
            unlockLabel.textContent = 'All Gens Unlocked!';
            unlockProgressBar.style.width = '100%';
            unlockProgressText.textContent = 'Congratulations!';
        }
    }

    function checkEndConditions() {
        const canAffordAnyPack = Object.keys(PACK_DEFINITIONS).some(packKey => {
            if (!metaState.unlockedGens.includes(packKey) && !metaState.unlockedLicenses.includes(packKey)) return false;
            const numPurchased = state.packsPurchased[packKey] || 0;
            const costIncrease = (numPurchased * (numPurchased + 1) / 2) * 0.01;
            const cost = (PACK_DEFINITIONS[packKey].cost + costIncrease) * (1 - state.shopDiscount);
            return state.money >= cost;
        });

        if (!canAffordAnyPack && packOpeningGrid.children.length === 0 && state.money < 5) { 
            endRun('noMoney');
        }
    }
    
    function endRun(reason) {
        // Stop autoplay if it's running
        if (state.autoplayEnabled) {
            stopAutoplay();
            state.autoplayEnabled = false;
            autoplayBtn.textContent = '🤖 Autoplay';
            autoplayBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            autoplayBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
        }

        // Mark run as ended
        state.runEnded = true;

        const newCollectionBookValue = metaState.collectionBook.reduce((sum, card) => sum + getPersistentCardValue(card), 0);
        const newCardsValue = newCollectionBookValue - state.initialCollectionBookValue;

        // Check for any final unlocks (though they should have been caught earlier)
        const newlyUnlocked = checkForNewUnlocks();
        const newUnlockText = newlyUnlocked.length > 0 ? `You've unlocked ${newlyUnlocked.join(', ').toUpperCase()} packs!` : "";

        // Store last run data for "View Last Run" functionality
        metaState.lastRunData = {
            reason: reason,
            finalValue: state.deckValue,
            newCardsValue: newCardsValue,
            collectionValue: newCollectionBookValue,
            progressUpdate: newUnlockText,
            mostValuableCard: state.deck.length > 0 ? state.deck.reduce((best, current) => {
                return getCardValue(current) > getCardValue(best) ? current : best;
            }) : null,
            timestamp: new Date().toISOString()
        };

        saveMetaState();

        let mostValuableCard = null;
        if (state.deck.length > 0) {
            mostValuableCard = state.deck.reduce((best, current) => {
                return getCardValue(current) > getCardValue(best) ? current : best;
            });
        }

        modalNewRunBtn.classList.add('hidden');
        modalClaimRewardBtn.classList.remove('hidden');
        modalClaimRewardBtn.disabled = false;
        modalClaimRewardBtn.innerHTML = 'Claim Reward';
        modalRewardCardContainer.classList.add('hidden');
        modalRewardCard.innerHTML = '';

        gameOverModal.classList.remove('hidden');
        gameOverModal.classList.add('flex');
        
        let message = 'Your run has ended.';
        if (reason === 'deckFull') {
            message = 'Your deck is full!';
        } else if (reason === 'noMoney') {
            message = 'You ran out of money!';
        } else if (reason === 'manual') {
            message = 'You ended the run.';
        }
        modalMessage.textContent = message;

        modalFinalValue.textContent = formatMoney(state.deckValue);
        modalNewCardsValue.textContent = formatMoney(newCardsValue, true);
        modalCollectionValue.textContent = formatMoney(newCollectionBookValue);
        modalProgressUpdate.textContent = newUnlockText;
        
        modalBestCard.innerHTML = '';
        if (mostValuableCard) {
            const cardEl = createCardElement(mostValuableCard, 'collection');
            modalBestCard.appendChild(cardEl);
        }
    }
    
    async function processEndRunReward() {
        try {
            modalClaimRewardBtn.disabled = true;
            modalClaimRewardBtn.innerHTML = `<div class="loader mx-auto"></div>`;

            await new Promise(resolve => setTimeout(resolve, 50));

            const numRolls = Math.floor(state.deckValue);
            console.log(`Processing reward with ${numRolls} rolls for deck value ${state.deckValue}`);

            if (numRolls <= 0) {
                modalRewardCard.innerHTML = `<p class="text-gray-400 text-sm">Deck value was too low for a reward.</p>`;
                modalRewardCardContainer.classList.remove('hidden');
                modalClaimRewardBtn.classList.add('hidden');
                modalNewRunBtn.classList.remove('hidden');
                return;
            }

            // Cap the number of rolls to prevent excessive processing
            const cappedRolls = Math.min(numRolls, 10000);
            if (numRolls > 10000) {
                console.warn(`Capping reward rolls from ${numRolls} to 10000 to prevent performance issues`);
            }

            const cardPool = metaState.unlockedGens.flatMap(genKey => CARD_GENERATIONS[genKey]);
            if (!cardPool || cardPool.length === 0) {
                throw new Error('No cards available in unlocked generations');
            }

            console.log(`Card pool has ${cardPool.length} cards from generations: ${metaState.unlockedGens.join(', ')}`);

            let bestRewardCard = null;
            let processedRolls = 0;

            for (let i = 0; i < cappedRolls; i++) {
                try {
                    const rolledCard = generateRandomCardFromPools(cardPool);
                    if (!rolledCard) {
                        console.warn(`Failed to generate card on roll ${i + 1}`);
                        continue;
                    }

                    const existingCard = metaState.collectionBook.find(c => c.id === rolledCard.id);
                    const rolledValue = getPersistentCardValue(rolledCard);

                    let isCandidate = false;
                    if (!existingCard) {
                        isCandidate = true;
                    } else if (rolledValue > getPersistentCardValue(existingCard)) {
                        isCandidate = true;
                    }

                    if (isCandidate) {
                        if (!bestRewardCard || rolledValue > getPersistentCardValue(bestRewardCard)) {
                            bestRewardCard = rolledCard;
                        }
                    }

                    processedRolls++;

                    // Yield control periodically for very large roll counts
                    if (i > 0 && i % 1000 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                } catch (rollError) {
                    console.error(`Error on roll ${i + 1}:`, rollError);
                    // Continue with next roll instead of failing completely
                }
            }

            console.log(`Processed ${processedRolls} rolls, best reward: ${bestRewardCard ? bestRewardCard.name : 'none'}`);

            if (bestRewardCard) {
                updateCollectionBook(bestRewardCard);
                const cardEl = createCardElement(bestRewardCard, 'book');
                modalRewardCard.innerHTML = '';
                modalRewardCard.appendChild(cardEl);
            } else {
                modalRewardCard.innerHTML = `<p class="text-gray-400 text-sm p-4">No new cards or upgrades found from ${cappedRolls.toLocaleString()} rolls.</p>`;
            }

            // Store reward card in last run data
            if (metaState.lastRunData) {
                metaState.lastRunData.rewardCard = bestRewardCard;
                metaState.lastRunData.numRolls = cappedRolls;
                saveMetaState();
            }

            modalRewardCardContainer.classList.remove('hidden');
            modalClaimRewardBtn.classList.add('hidden');
            modalNewRunBtn.classList.remove('hidden');

        } catch (error) {
            console.error('Error processing end run reward:', error);

            // Show error message and restore UI
            modalRewardCard.innerHTML = `<p class="text-red-400 text-sm p-4">Error processing reward: ${error.message}</p>`;
            modalRewardCardContainer.classList.remove('hidden');
            modalClaimRewardBtn.classList.add('hidden');
            modalNewRunBtn.classList.remove('hidden');
        }
    }

    function generateRandomCardFromPools(cardPool) {
        if (!cardPool || cardPool.length === 0) {
            console.error('generateRandomCardFromPools called with empty card pool');
            return null;
        }

        const randRarity = Math.random();
        let baseRarity;
        if (randRarity < 0.01) baseRarity = BASE_RARITIES.SECRET_RARE;
        else if (randRarity < 0.05) baseRarity = BASE_RARITIES.ULTRA_RARE;
        else if (randRarity < 0.15) baseRarity = BASE_RARITIES.RARE;
        else if (randRarity < 0.40) baseRarity = BASE_RARITIES.UNCOMMON;
        else baseRarity = BASE_RARITIES.COMMON;

        let possibleCards = cardPool.filter(c => c.baseRarity === baseRarity);

        // Fallback to any rarity if none found for selected rarity
        if (possibleCards.length === 0) {
            console.warn(`No cards found for rarity ${baseRarity.name}, falling back to any rarity`);
            possibleCards = cardPool;
        }

        if (possibleCards.length === 0) {
            console.error('No cards available in card pool');
            return null;
        }

        const cardTemplate = possibleCards[Math.floor(Math.random() * possibleCards.length)];

        if (!cardTemplate) {
            console.error('Failed to select card template');
            return null;
        }

        let cardCondition = 1 + ((Math.random() + Math.random() + Math.random()) / 3) * 9;
        cardCondition = Math.max(0.1, Math.min(11, cardCondition));
        cardCondition = parseFloat(cardCondition.toFixed(1));

        const finishes = generateFinishes(baseRarity, false, { luckBonus: 0 });
        return { ...cardTemplate, finishes: finishes, condition: cardCondition, keeps: 0 };
    }


    // --- CARD DETAIL MODAL ---
    function showCardDetailModal(card) {
        cardDetailContainer.innerHTML = '';
        const largeCardEl = createCardElement(card, 'detail');
        largeCardEl.classList.add('card-scaled');
        cardDetailContainer.appendChild(largeCardEl);
        cardDetailModal.classList.remove('hidden');
        cardDetailModal.classList.add('flex');
    }

    function closeCardDetailModal() {
        cardDetailModal.classList.add('hidden');
        cardDetailModal.classList.remove('flex');
    }

    function closeGameOverModal() {
        gameOverModal.classList.add('hidden');
        gameOverModal.classList.remove('flex');

        // Reset button states for normal end run flow
        modalNewRunBtn.classList.remove('hidden');
        modalCloseBtn.classList.add('hidden');
        modalRewardCardContainer.classList.add('hidden');
    }

    // --- COLLECTION BOOK ACTIONS ---
    function viewLastRun() {
        if (!metaState.lastRunData) {
            alert('No previous run data available.');
            return;
        }

        const lastRun = metaState.lastRunData;

        // Populate the game over modal with last run data
        modalNewRunBtn.classList.add('hidden');
        modalClaimRewardBtn.classList.add('hidden');
        modalCloseBtn.classList.remove('hidden');

        let message = 'Your last run ended.';
        if (lastRun.reason === 'deckFull') {
            message = 'Your deck was full!';
        } else if (lastRun.reason === 'noMoney') {
            message = 'You ran out of money!';
        } else if (lastRun.reason === 'manual') {
            message = 'You ended the run.';
        }
        modalMessage.textContent = message;

        modalFinalValue.textContent = formatMoney(lastRun.finalValue);
        modalNewCardsValue.textContent = formatMoney(lastRun.newCardsValue, true);
        modalCollectionValue.textContent = formatMoney(lastRun.collectionValue);
        modalProgressUpdate.textContent = lastRun.progressUpdate;

        modalBestCard.innerHTML = '';
        if (lastRun.mostValuableCard) {
            const cardEl = createCardElement(lastRun.mostValuableCard, 'collection');
            modalBestCard.appendChild(cardEl);
        }

        // Show reward card if available
        modalRewardCard.innerHTML = '';
        if (lastRun.rewardCard) {
            const cardEl = createCardElement(lastRun.rewardCard, 'book');
            modalRewardCard.appendChild(cardEl);
            modalRewardCardContainer.classList.remove('hidden');
        } else if (lastRun.numRolls !== undefined) {
            if (lastRun.numRolls <= 0) {
                modalRewardCard.innerHTML = `<p class="text-gray-400 text-sm">Deck value was too low for a reward.</p>`;
            } else {
                modalRewardCard.innerHTML = `<p class="text-gray-400 text-sm p-4">No new cards or upgrades found from ${lastRun.numRolls.toLocaleString()} rolls.</p>`;
            }
            modalRewardCardContainer.classList.remove('hidden');
        } else {
            modalRewardCardContainer.classList.add('hidden');
        }

        // Close collection book and show game over modal
        closeCollectionBook();
        gameOverModal.classList.remove('hidden');
        gameOverModal.classList.add('flex');
    }

    function showClearProgressModal() {
        clearProgressModal.classList.remove('hidden');
        clearProgressModal.classList.add('flex');
    }

    function closeClearProgressModal() {
        clearProgressModal.classList.add('hidden');
        clearProgressModal.classList.remove('flex');
    }

    function clearAllProgress() {
        // Reset metaState to default
        metaState = {
            collectionBook: [],
            bigBook: [],
            unlockedGens: ['gen1'],
            unlockedLicenses: [],
            showConditionIndicator: true,
            showNewCardIndicator: true,
            showUpgradeCardIndicator: true,
            lastRunData: null,
        };

        // Save the reset state
        saveMetaState();

        // Close the confirmation modal
        closeClearProgressModal();
        closeCollectionBook();

        // Show success modal
        showProgressClearedModal();
    }

    function showProgressClearedModal() {
        // Create and show the progress cleared modal
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 z-50 flex items-center justify-center modal-backdrop';
        modal.innerHTML = `
            <div class="bg-gray-800 rounded-2xl shadow-2xl p-8 text-center max-w-md mx-auto border-2 border-green-500">
                <div class="text-6xl mb-4">✅</div>
                <h2 class="text-2xl font-bold text-green-400 mb-4">Progress Cleared!</h2>
                <p class="text-gray-300 text-sm mb-6">All your progress has been successfully cleared. Click refresh to start fresh.</p>
                <button onclick="location.reload()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded transition-colors flex items-center gap-2 mx-auto">
                    <span>🔄</span>
                    Refresh Page
                </button>
            </div>
        `;
        document.body.appendChild(modal);
    }


    // --- UNLOCK CODE FUNCTIONS ---
    function processUnlockCode() {
        const code = unlockCodeInput.value.trim().toLowerCase();

        if (!code) {
            unlockCodeMessage.textContent = 'Please enter a code.';
            unlockCodeMessage.className = 'text-sm text-red-400 mb-4 min-h-[1.25rem]';
            return;
        }

        // Check if code is valid
        if (code === 'binderbuster') {
            executeBinderBusterCode();
        } else if (code === 'bigdeckenergy') {
            executeBigDeckEnergyCode();
        } else if (code === 'momoneymoshrooms') {
            executeMoMoneyMoShroomsCode();
        } else if (code === 'malicioushroom') {
            executeMaliciousShroomCode();
        } else if (code === 'cashroom') {
            executeCashroomCode();
        } else if (code === 'premiumprinters') {
            executePremiumPrintersCode();
        } else if (code === 'supershinysparkly') {
            executeSupershinySparklyCode();
        } else if (code === 'mipssrint') {
            executeMipssprintCode();
        } else if (code === 'agent00shroom') {
            executeAgent00ShroomCode();
        } else {
            unlockCodeMessage.textContent = 'Invalid code. Please try again.';
            unlockCodeMessage.className = 'text-sm text-red-400 mb-4 min-h-[1.25rem]';
        }
    }

    function executeBinderBusterCode() {
        // Add one of every card to the collection
        const allCards = [];

        // Collect all cards from all generations
        Object.values(CARD_GENERATIONS).forEach(generation => {
            generation.forEach(cardDef => {
                allCards.push(cardDef);
            });
        });

        let cardsAdded = 0;

        // For each card, create a standard version and add to collection if not already present
        allCards.forEach(cardDef => {
            const existingCard = metaState.collectionBook.find(c => c.id === cardDef.id);

            if (!existingCard) {
                // Create a standard version of the card
                const newCard = {
                    ...cardDef,
                    finishes: [FINISHES.STANDARD],
                    condition: 5.0 // Average condition
                };

                metaState.collectionBook.push(newCard);
                updateBigBook(newCard);
                cardsAdded++;
            }
        });

        // Save the updated collection
        saveMetaState();

        // Check for new unlocks
        checkForNewUnlocks();

        // Show success message
        unlockCodeMessage.textContent = `Success! Added ${cardsAdded} new cards to your collection.`;
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        // Close modal after a delay
        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');

            // Update the UI to reflect new collection value
            updateUnlockProgressUI();

            // Show a notification about the collection update
            if (cardsAdded > 0) {
                showNotification(`Binder Buster activated! ${cardsAdded} cards added to your collection.`);
            } else {
                showNotification('Binder Buster activated! You already have all cards in your collection.');
            }
        }, 2000);
    }

    function executeBigDeckEnergyCode() {
        metaState.unlockCodeEffects.bigDeckEnergy = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Big Deck Energy activated! Double deck size and deck size buffs.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Big Deck Energy activated! Your deck size has been doubled!');

            // If currently in a run, update the deck size immediately
            if (state) {
                applyBigDeckEnergyEffect();
                recalculateState();
            }
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function executeMoMoneyMoShroomsCode() {
        metaState.unlockCodeEffects.moMoneyMoShrooms = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Mo Money Mo Shrooms activated! Double starting money and +100% sell value.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Mo Money Mo Shrooms activated! Double money and sell bonuses applied!');

            // If currently in a run, update money immediately
            if (state) {
                applyMoMoneyMoShroomsEffect();
                recalculateState();
            }
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function executeMaliciousShroomCode() {
        metaState.unlockCodeEffects.maliciousShroom = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Malicious Shroom activated! Hard mode: Half money, half deck size, no sells/burns, -50% sell value.';
        unlockCodeMessage.className = 'text-sm text-orange-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Malicious Shroom activated! Hard mode enabled - good luck!');

            // If currently in a run, apply effects immediately
            if (state) {
                applyMaliciousShroomEffect();
                recalculateState();
            }
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function executeCashroomCode() {
        // Give immediate $1000 boost
        if (state) {
            state.money += 1000;
            recalculateState(); // Update the UI
        }

        unlockCodeMessage.textContent = 'Cashroom activated! +$1000 added to your current money.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');

            if (state) {
                showNotification('Cashroom activated! +$1000 added to your money!');
            } else {
                showNotification('Cashroom activated! Start a run to use your bonus money!');
            }
        }, 2000);
    }

    function executePremiumPrintersCode() {
        metaState.unlockCodeEffects.premiumPrinters = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Premium Printers activated! All cards from packs are now Gem Mint condition.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Premium Printers activated! All future cards will be Gem Mint!');
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function executeSupershinySparklyCode() {
        metaState.unlockCodeEffects.supershinySparkly = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Super Shiny Sparkly activated! Cards are 100x more likely to have special finishes.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Super Shiny Sparkly activated! Special finishes are now much more common!');
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function executeMipssprintCode() {
        // Generate a random misprint card
        const misprintCard = generateRandomMisprintCard();

        console.log('Generated misprint card:', misprintCard);
        console.log('Misprint card finishes:', misprintCard.finishes);
        console.log('FINISHES.MISPRINT:', FINISHES.MISPRINT);

        // Add it to the collection
        metaState.collectionBook.push(misprintCard);
        console.log('Added to collection book, new size:', metaState.collectionBook.length);

        updateBigBook(misprintCard);
        console.log('Updated big book, new size:', metaState.bigBook.length);

        saveMetaState();

        // Check for new unlocks
        checkForNewUnlocks();

        unlockCodeMessage.textContent = `Mipssrint activated! A random misprint card "${misprintCard.name}" has been added to your collection.`;
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');

            // Show the misprint card in a popup
            showMisprintRewardModal(misprintCard);

            showNotification(`Mipssrint activated! Random misprint "${misprintCard.name}" added to collection!`);
        }, 2000);
    }

    function showMisprintRewardModal(misprintCard) {
        // Clear previous card
        misprintRewardCard.innerHTML = '';

        // Create and display the misprint card
        const cardElement = createCardElement(misprintCard, 'collection');
        cardElement.style.transform = 'scale(0.8)'; // Make it slightly smaller to fit nicely
        misprintRewardCard.appendChild(cardElement);

        // Show the modal
        misprintRewardModal.classList.remove('hidden');
        misprintRewardModal.classList.add('flex');
    }

    function generateRandomMisprintCard() {
        // Get all available cards from all generations
        const allCards = [];
        Object.values(CARD_GENERATIONS).forEach(gen => {
            allCards.push(...gen);
        });

        // Pick a random card template
        const randomCard = allCards[Math.floor(Math.random() * allCards.length)];

        // Generate normal finishes first, then force add misprint
        const normalFinishes = generateFinishes(randomCard.baseRarity, false, null);

        // Remove misprint if it was randomly generated (we'll add it manually)
        const finishesWithoutMisprint = normalFinishes.filter(f => f !== FINISHES.MISPRINT);

        // Always add misprint finish
        const allFinishes = [...finishesWithoutMisprint, FINISHES.MISPRINT];

        console.log(`Generated misprint card ${randomCard.name} with finishes:`, allFinishes.map(f => f.name));

        // Create a copy with all finishes including misprint
        const misprintCard = {
            ...randomCard,
            finishes: allFinishes,
            condition: 5.0 + Math.random() * 5.0, // Random condition between 5.0-10.0
            keeps: 0,
            // Keep original ID so it matches the card generations
            // Generate and store misprint errors permanently
            misprintErrors: generateMisprintErrors(randomCard)
        };

        return misprintCard;
    }

    function generateMisprintErrors(card) {
        const errorTypes = [
            'name_typo',
            'missing_text',
            'image_offset',
            'image_rotated',
            'image_inverted',
            'image_color_error',
            'effect_typo'
        ];

        // Apply 1-3 random errors
        const numErrors = Math.floor(Math.random() * 3) + 1;
        const selectedErrors = [];

        for (let i = 0; i < numErrors; i++) {
            const errorType = errorTypes[Math.floor(Math.random() * errorTypes.length)];
            if (!selectedErrors.includes(errorType)) {
                selectedErrors.push(errorType);
            }
        }

        const errors = {
            types: selectedErrors,
            data: {}
        };

        // Generate specific error data
        selectedErrors.forEach(errorType => {
            switch (errorType) {
                case 'name_typo':
                    errors.data.corruptedName = createTypo(card.name);
                    break;
                case 'effect_typo':
                    if (card.desc) {
                        errors.data.corruptedEffect = createTypo(card.desc);
                    }
                    break;
                // Other error types don't need stored data (they're CSS classes)
            }
        });

        return errors;
    }

    function executeAgent00ShroomCode() {
        metaState.unlockCodeEffects.agent00Shroom = true;
        saveMetaState();

        unlockCodeMessage.textContent = 'Agent 00 Shroom activated! Autoplay button unlocked.';
        unlockCodeMessage.className = 'text-sm text-green-400 mb-4 min-h-[1.25rem]';

        // Show the autoplay button
        updateAutoplayButtonVisibility();

        // Close modal after delay
        setTimeout(() => {
            unlockCodeModal.classList.add('hidden');
            unlockCodeModal.classList.remove('flex');
            showNotification('Agent 00 Shroom activated! Autoplay button is now available!');
        }, 2000);

        // Update the active unlocks list immediately
        updateActiveUnlocksList();
    }

    function updateAutoplayButtonVisibility() {
        if (metaState.unlockCodeEffects.agent00Shroom) {
            autoplayBtn.classList.remove('hidden');
        } else {
            autoplayBtn.classList.add('hidden');
        }
    }

    function toggleAutoplay() {
        console.log('🤖 Toggle autoplay clicked, current state:', state.autoplayEnabled);
        state.autoplayEnabled = !state.autoplayEnabled;
        console.log('🤖 New autoplay state:', state.autoplayEnabled);

        if (state.autoplayEnabled) {
            autoplayBtn.textContent = '⏸️ Stop Auto';
            autoplayBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
            autoplayBtn.classList.add('bg-red-600', 'hover:bg-red-700');
            console.log('🤖 Starting autoplay...');
            startAutoplay();
        } else {
            autoplayBtn.textContent = '🤖 Autoplay';
            autoplayBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            autoplayBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
            console.log('🤖 Stopping autoplay...');
            stopAutoplay();
        }
    }

    function startAutoplay() {
        if (state.autoplayInterval) {
            clearInterval(state.autoplayInterval);
        }

        console.log('🤖 Autoplay started');

        // Run autoplay logic every 1 second
        state.autoplayInterval = setInterval(() => {
            performAutoplayAction();
        }, 1000);
    }

    function stopAutoplay() {
        if (state.autoplayInterval) {
            clearInterval(state.autoplayInterval);
            state.autoplayInterval = null;
        }
        console.log('⏸️ Autoplay stopped');
    }

    function performAutoplayAction() {
        console.log('🤖 Autoplay tick - checking state...');
        console.log('🤖 Run ended:', state.runEnded);
        console.log('🤖 Opened cards in DOM:', packOpeningGrid.children.length);
        console.log('🤖 Money:', formatMoney(state.money));

        // Stop if run is over
        if (state.runEnded) {
            console.log('🤖 Run ended, stopping autoplay');
            stopAutoplay();
            return;
        }

        // If there are opened cards in the DOM, process them first
        if (packOpeningGrid.children.length > 0) {
            console.log('🤖 Processing opened cards...');
            processOpenedCardsAutoplay();
            return;
        }

        // If no opened cards, try to buy a pack
        console.log('🤖 No opened cards, trying to buy pack...');
        buyPackAutoplay();
    }

    function processOpenedCardsAutoplay() {
        // Process one card at a time for better visual feedback
        if (packOpeningGrid.children.length === 0) {
            console.log('🤖 No cards to process');
            return;
        }

        // Get the first card element
        const cardWithButtons = packOpeningGrid.children[0];
        const cardElement = cardWithButtons.querySelector('.card');

        // Extract card data from the DOM element
        const cardData = cardElement.cardData;
        if (!cardData) {
            console.log('🤖 No card data found, removing element');
            cardWithButtons.remove();
            return;
        }

        console.log(`🤖 Processing card: ${cardData.name}`);

        // Use the EXACT same logic as the NEW and UPGRADE indicators
        const existingCard = metaState.collectionBook.find(c => c.id === cardData.id);

        // NEW card logic: not in collection at all
        const isNewCard = !existingCard;

        // UPGRADE card logic: exists in collection but this one has better value
        const isUpgrade = existingCard && getPersistentCardValue(cardData) > getPersistentCardValue(existingCard);

        // Keep if it qualifies for NEW or UPGRADE indicator
        const shouldKeep = isNewCard || isUpgrade;

        if (isNewCard) {
            console.log(`🤖 NEW card ${cardData.name} (value: ${formatMoney(getPersistentCardValue(cardData))}) - KEEPING`);
        } else if (isUpgrade) {
            console.log(`🤖 UPGRADE ${cardData.name} (${formatMoney(getPersistentCardValue(cardData))} > ${formatMoney(getPersistentCardValue(existingCard))}) - KEEPING`);
        } else {
            const existingValue = existingCard ? getPersistentCardValue(existingCard) : 0;
            console.log(`🤖 Already have better ${cardData.name} (current: ${formatMoney(getPersistentCardValue(cardData))}, existing: ${formatMoney(existingValue)}) - SELLING`);
        }

        if (shouldKeep) {
            // Keep the card - simulate clicking the keep button
            const keepButton = cardWithButtons.querySelector('button:first-child');
            if (keepButton) {
                console.log(`🤖 Keeping ${cardData.name}`);
                keepButton.click();
            }
        } else {
            // Sell the card - simulate clicking the sell button
            const sellButton = cardWithButtons.querySelector('button:last-child');
            if (sellButton) {
                console.log(`🤖 Selling ${cardData.name}`);
                sellButton.click();
            }
        }
    }



    function buyPackAutoplay() {
        console.log('🤖 Looking for packs to buy...');
        console.log('🤖 Current money:', formatMoney(state.money));

        // Find the cheapest available pack
        const availablePacks = Object.entries(PACK_DEFINITIONS).filter(([key, pack]) => {
            // Calculate actual cost including increases and discounts
            const numPurchased = state.packsPurchased[key] || 0;
            const costIncrease = (numPurchased * (numPurchased + 1) / 2) * 0.01;
            let actualCost = (pack.cost + costIncrease) * (1 - state.shopDiscount);

            // Check for first pack free effect
            if ((state.packsPurchased['total'] || 0) === 0 && metaState.collectionBook.some(c => c.id === 196)) {
                actualCost = 0;
            }

            const canAfford = actualCost <= state.money;
            const isUnlocked = metaState.unlockedGens.includes(key) || metaState.unlockedLicenses.includes(key);
            console.log(`🤖 Pack ${key}: base cost ${formatMoney(pack.cost)}, actual cost ${formatMoney(actualCost)}, can afford: ${canAfford}, unlocked: ${isUnlocked}`);

            // Store actual cost for later use
            pack.actualCost = actualCost;

            return canAfford && isUnlocked;
        });

        console.log(`🤖 Found ${availablePacks.length} available packs`);

        if (availablePacks.length === 0) {
            // No packs available, end run
            console.log('🤖 No packs available, ending run');
            endRun('noMoney');
            return;
        }

        // Sort by actual cost (cheapest first)
        availablePacks.sort((a, b) => a[1].actualCost - b[1].actualCost);
        const [packKey, pack] = availablePacks[0];

        console.log(`🤖 Buying ${pack.name} for ${formatMoney(pack.actualCost)}`);

        // Use the existing buyPack function to ensure consistency
        buyPack(packKey);
    }

    function showNotification(message) {
        // Create a temporary notification element
        const notification = document.createElement('div');
        notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-opacity duration-500';
        notification.textContent = message;
        document.body.appendChild(notification);

        // Remove after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 500);
        }, 3000);
    }

    // --- UNLOCK CODE EFFECT HELPERS ---
    function applyBigDeckEnergyEffect() {
        // Effects are now applied in recalculateState, this just triggers a recalculation
        // Double deck size effect is handled in recalculateState
    }

    function applyMoMoneyMoShroomsEffect() {
        // Double current money (but only if we haven't already applied this effect)
        if (!state.moMoneyEffectApplied) {
            state.money *= 2;
            state.moMoneyEffectApplied = true;
        }
        // Sell value effect is handled in recalculateState and getSellValue
    }

    function applyMaliciousShroomEffect() {
        // Halve current money
        state.money = Math.floor(state.money / 2);

        // Set sells and burns to 0
        state.sellsLeft = 0;
        state.burnsLeft = 0;

        // Deck size and sell value effects are handled in recalculateState and getSellValue
    }

    // --- UNLOCK CODE UI FUNCTIONS ---
    function updateActiveUnlocksList() {
        activeUnlocksList.innerHTML = '';

        const unlockCodeData = [
            {
                key: 'bigDeckEnergy',
                name: 'Big Deck Energy',
                icon: '🚀',
                description: 'Double deck size & deck size buffs'
            },
            {
                key: 'moMoneyMoShrooms',
                name: 'Mo Money Mo Shrooms',
                icon: '💰',
                description: 'Double starting money & +100% sell value'
            },
            {
                key: 'maliciousShroom',
                name: 'Malicious Shroom',
                icon: '☠️',
                description: 'Hard mode: Half money, half deck size, no sells/burns, -50% sell value'
            },
            {
                key: 'premiumPrinters',
                name: 'Premium Printers',
                icon: '💎',
                description: 'All cards from packs are Gem Mint condition'
            },
            {
                key: 'supershinySparkly',
                name: 'Super Shiny Sparkly',
                icon: '✨',
                description: 'Cards are 100x more likely to have special finishes'
            }
        ];

        const activeUnlocks = unlockCodeData.filter(unlock => metaState.unlockCodeEffects[unlock.key]);

        if (activeUnlocks.length === 0) {
            activeUnlocksSection.style.display = 'none';
        } else {
            activeUnlocksSection.style.display = 'block';

            activeUnlocks.forEach(unlock => {
                const unlockEl = document.createElement('div');
                unlockEl.className = 'flex items-center justify-between bg-gray-700 rounded-lg p-3';
                unlockEl.innerHTML = `
                    <div class="flex items-center gap-3">
                        <span class="text-2xl">${unlock.icon}</span>
                        <div class="text-left">
                            <div class="font-semibold text-white">${unlock.name}</div>
                            <div class="text-xs text-gray-400">${unlock.description}</div>
                        </div>
                    </div>
                    <button class="disable-unlock-btn bg-red-600 hover:bg-red-700 text-white font-bold w-8 h-8 rounded-full flex items-center justify-center transition-colors" data-unlock="${unlock.key}" title="Disable this unlock">
                        ×
                    </button>
                `;
                activeUnlocksList.appendChild(unlockEl);
            });

            // Add event listeners to disable buttons
            activeUnlocksList.querySelectorAll('.disable-unlock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const unlockKey = e.target.dataset.unlock;
                    disableUnlockCode(unlockKey);
                });
            });
        }
    }

    function disableUnlockCode(unlockKey) {
        // Disable the unlock code
        metaState.unlockCodeEffects[unlockKey] = false;
        saveMetaState();

        // Update the UI
        updateActiveUnlocksList();

        // Show confirmation message
        const unlockNames = {
            bigDeckEnergy: 'Big Deck Energy',
            moMoneyMoShrooms: 'Mo Money Mo Shrooms',
            maliciousShroom: 'Malicious Shroom',
            premiumPrinters: 'Premium Printers',
            supershinySparkly: 'Super Shiny Sparkly'
        };

        unlockCodeMessage.textContent = `${unlockNames[unlockKey]} has been disabled.`;
        unlockCodeMessage.className = 'text-sm text-orange-400 mb-4 min-h-[1.25rem]';

        // Clear message after 3 seconds
        setTimeout(() => {
            unlockCodeMessage.textContent = '';
            unlockCodeMessage.className = 'text-sm text-gray-400 mb-4 min-h-[1.25rem]';
        }, 3000);

        // If currently in a run, show notification that effects will apply on next run
        if (state) {
            showNotification(`${unlockNames[unlockKey]} disabled. Effects will apply on next run.`);
        }
    }

    // --- EVENT LISTENERS ---
    endRunBtn.addEventListener('click', () => endRun('manual'));
    modalNewRunBtn.addEventListener('click', startGame);
    modalClaimRewardBtn.addEventListener('click', () => {
        // Add timeout protection
        const timeoutId = setTimeout(() => {
            console.error('Reward processing timed out after 30 seconds');
            modalRewardCard.innerHTML = `<p class="text-red-400 text-sm p-4">Reward processing timed out. Please try starting a new run.</p>`;
            modalRewardCardContainer.classList.remove('hidden');
            modalClaimRewardBtn.classList.add('hidden');
            modalNewRunBtn.classList.remove('hidden');
        }, 30000); // 30 second timeout

        processEndRunReward().finally(() => {
            clearTimeout(timeoutId);
        });
    });
    modalCloseBtn.addEventListener('click', closeGameOverModal);
    enterShopBtn.addEventListener('click', showFullShop);
    closeShopBtn.addEventListener('click', closeFullShop);
    restockMerchBtn.addEventListener('click', restockMerchandise);
    collectionBookBtn.addEventListener('click', showCollectionBook);
    closeCollectionBookBtn.addEventListener('click', closeCollectionBook);
    bigBookBtn.addEventListener('click', showBigBook);
    closeBigBookBtn.addEventListener('click', closeBigBook);
    viewLastRunBtn.addEventListener('click', viewLastRun);
    clearProgressBtn.addEventListener('click', showClearProgressModal);
    cancelClearBtn.addEventListener('click', closeClearProgressModal);
    confirmClearBtn.addEventListener('click', clearAllProgress);
    closePackOddsBtn.addEventListener('click', closePackOddsModal);
    closeCardDetailBtn.addEventListener('click', closeCardDetailModal);
    infoBtn.addEventListener('click', () => {
        infoModal.classList.remove('hidden');
        infoModal.classList.add('flex');
    });
    closeInfoBtn.addEventListener('click', () => {
        infoModal.classList.add('hidden');
        infoModal.classList.remove('flex');
    });

    // Unlock Code Modal Event Listeners
    unlockingText.addEventListener('click', () => {
        unlockCodeModal.classList.remove('hidden');
        unlockCodeModal.classList.add('flex');
        unlockCodeInput.value = '';
        unlockCodeMessage.textContent = '';
        updateActiveUnlocksList();
        unlockCodeInput.focus();
    });

    cancelUnlockBtn.addEventListener('click', () => {
        unlockCodeModal.classList.add('hidden');
        unlockCodeModal.classList.remove('flex');
    });

    enterUnlockBtn.addEventListener('click', processUnlockCode);

    unlockCodeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            processUnlockCode();
        }
    });

    // Misprint Reward Modal Event Listeners
    misprintRewardCloseBtn.addEventListener('click', () => {
        misprintRewardModal.classList.add('hidden');
        misprintRewardModal.classList.remove('flex');
    });
    
    collectionPrevBtn.addEventListener('click', () => {
        if (metaState.collectionBookView.currentPage > 1) {
            metaState.collectionBookView.currentPage--;
            renderCollectionBook();
        }
    });
    collectionNextBtn.addEventListener('click', () => {
        const cardsInGen = CARD_GENERATIONS[metaState.collectionBookView.activeGen];
        const totalPages = Math.ceil(cardsInGen.length / metaState.collectionBookView.cardsPerPage);
        if (metaState.collectionBookView.currentPage < totalPages) {
            metaState.collectionBookView.currentPage++;
            renderCollectionBook();
        }
    });

    bigBookPrevBtn.addEventListener('click', () => {
        if (metaState.bigBookView.currentPage > 1) {
            metaState.bigBookView.currentPage--;
            renderBigBook();
            saveMetaState(); // Save page state
        }
    });
    bigBookNextBtn.addEventListener('click', () => {
        const activeGen = metaState.bigBookView.activeGen;
        const cardsInGen = metaState.bigBook.filter(card => {
            const cardDef = CARD_GENERATIONS[activeGen].find(c => c.id === card.id);
            return cardDef !== undefined;
        });
        const totalPages = Math.max(1, Math.ceil(cardsInGen.length / metaState.bigBookView.cardsPerPage));
        if (metaState.bigBookView.currentPage < totalPages) {
            metaState.bigBookView.currentPage++;
            renderBigBook();
            saveMetaState(); // Save page state
        }
    });

    sellAllBtn.addEventListener('click', sellAllOpenedCards);
    autoplayBtn.addEventListener('click', toggleAutoplay);

    // Deck control event listeners
    deckToggle.addEventListener('click', () => {
        deckViewState.isCollapsed = !deckViewState.isCollapsed;
        deckToggleText.textContent = deckViewState.isCollapsed ? 'Show' : 'Hide';
        deckToggleIcon.textContent = deckViewState.isCollapsed ? '▶' : '▼';
        renderDeck();
    });

    deckSort.addEventListener('change', (e) => {
        deckViewState.sortBy = e.target.value;
        deckViewState.currentPage = 1; // Reset to first page when sorting
        renderDeck();
    });

    deckPrevPage.addEventListener('click', () => {
        if (deckViewState.currentPage > 1) {
            deckViewState.currentPage--;
            renderDeck();
        }
    });

    deckNextPage.addEventListener('click', () => {
        const sortedDeck = getSortedDeck();
        const totalPages = Math.ceil(sortedDeck.length / deckViewState.cardsPerPage);
        if (deckViewState.currentPage < totalPages) {
            deckViewState.currentPage++;
            renderDeck();
        }
    });

    elementalCountsIcons.addEventListener('click', (e) => {
        const iconContainer = e.target.closest('[data-type]');
        if (iconContainer) {
            const type = iconContainer.dataset.type;

            if (state.highlightedTypes.includes(type)) {
                // Remove type from highlights
                state.highlightedTypes = state.highlightedTypes.filter(t => t !== type);
                iconContainer.classList.remove('active');
            } else {
                // Add type to highlights
                state.highlightedTypes.push(type);
                iconContainer.classList.add('active');
            }

            // Update opened cards display
            const openCards = Array.from(packOpeningGrid.querySelectorAll('.card'));
            const cardData = openCards.map(c => c.cardData);
            if(cardData.length > 0) displayOpenedCards(cardData);

            // Update deck display
            renderDeck();
        }
    });

    toggleConditionIndicator.addEventListener('change', () => {
        metaState.showConditionIndicator = toggleConditionIndicator.checked;
        saveMetaState();
        updateOpenCardIndicators();
    });

    toggleNewIndicator.addEventListener('change', () => {
        metaState.showNewCardIndicator = toggleNewIndicator.checked;
        saveMetaState();
        updateOpenCardIndicators();
    });

    toggleUpgradeIndicator.addEventListener('change', () => {
        metaState.showUpgradeCardIndicator = toggleUpgradeIndicator.checked;
        saveMetaState();
        updateOpenCardIndicators();
    });
});
</script>
</body>
</html>